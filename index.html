<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quiz: R, R Markdown, Quarto y Shiny</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<style>
		/* Estilos personalizados para la paleta de colores y alineación */
		body {
			font-family: "Inter", sans-serif;
			/* Usar fuente Inter */
			background-color: #f4f7f6;
			/* Color de fondo suave */
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 100vh;
			padding: 20px;
		}

		.quiz-container {
			background-color: #ffffff;
			/* Fondo blanco */
			padding: 30px;
			border-radius: 15px;
			/* Bordes redondeados */
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			/* Sombra suave */
			max-width: 700px;
			/* Ancho máximo */
			width: 100%;
			text-align: center;
			/* Centrar contenido */
		}

		.question {
			margin-bottom: 20px;
			font-size: 1.1em;
			font-weight: bold;
			color: #333;
			/* Color de texto oscuro para la pregunta */
			text-align: left;
			/* Alinear texto de pregunta a la izquierda */
		}

		.options {
			text-align: left;
			/* Alinear opciones a la izquierda */
		}

		.options label {
			display: flex;
			/* Usar flexbox para alinear input y texto */
			align-items: center;
			/* Centrar verticalmente */
			margin-bottom: 10px;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color 0.3s ease, border-color 0.3s ease;
			/* Transición suave */
			position: relative;
			/* Necesario para posicionar el pseudo-elemento */
			padding-left: 35px;
			/* Espacio a la izquierda para el cuadrado personalizado */
		}

		.options label:hover {
			background-color: #ffeacc;
			/* Naranja claro para hover */
			border-color: #ff9800;
			/* Naranja para el borde en hover */
		}

		/* Ocultar el radio button nativo */
		.options input[type="radio"] {
			position: absolute;
			/* Posicionamiento absoluto para sacarlo del flujo */
			opacity: 0;
			/* Hacerlo completamente transparente */
			cursor: pointer;
			/* Mantener el cursor de puntero */
			height: 0;
			/* Altura cero */
			width: 0;
			/* Ancho cero */
		}

		/* Crear el cuadrado personalizado */
		.options label::before {
			content: '';
			/* Contenido vacío es necesario para pseudo-elementos */
			position: absolute;
			/* Posicionamiento absoluto con respecto al label */
			left: 10px;
			/* Distancia desde el borde izquierdo del label */
			top: 50%;
			/* Centrar verticalmente */
			transform: translateY(-50%);
			/* Ajuste final para centrado perfecto */
			width: 20px;
			/* Tamaño del cuadrado */
			height: 20px;
			/* Tamaño del cuadrado */
			border: 2px solid #007bff;
			/* Borde azul */
			border-radius: 4px;
			/* Bordes ligeramente redondeados para el cuadrado */
			background-color: #fff;
			/* Fondo blanco */
			transition: all 0.3s ease;
			/* Transición suave para cambios */
		}

		/* Estilo para el cuadrado cuando el radio button está seleccionado */
		.options input[type="radio"]:checked+label::before {
			background-color: #007bff;
			/* Fondo azul cuando está seleccionado */
			border-color: #007bff;
			/* Borde azul cuando está seleccionado */
		}

		/* Estilo para el punto interior del cuadrado (opcional, si se desea un punto) */
		.options label::after {
			content: '';
			position: absolute;
			left: 16px;
			/* Ajustar la posición para que quede centrado en el cuadrado */
			top: 50%;
			transform: translateY(-50%);
			width: 8px;
			/* Tamaño del punto */
			height: 8px;
			/* Tamaño del punto */
			border-radius: 50%;
			/* Forma redonda */
			background-color: #fff;
			/* Color blanco para el punto */
			opacity: 0;
			/* Ocultar por defecto */
			transition: opacity 0.3s ease;
		}

		/* Mostrar el punto interior cuando el radio button está seleccionado */
		.options input[type="radio"]:checked+label::after {
			opacity: 1;
			/* Mostrar el punto */
		}


		.feedback {
			margin-top: 20px;
			padding: 15px;
			border-radius: 8px;
			text-align: left;
			/* Alinear feedback a la izquierda */
		}

		.feedback.correct {
			background-color: #d4edda;
			/* Verde claro (mantener para correcto por convención) */
			color: #155724;
			/* Verde oscuro */
			border-color: #c3e6cb;
		}

		.feedback.incorrect {
			background-color: #f8d7da;
			/* Rojo claro (mantener para incorrecto por convención) */
			color: #721c24;
			/* Rojo oscuro */
			border-color: #f5c6cb;
		}

		/* Estilo para el feedback de "selecciona una opción" */
		.feedback.warning {
			background-color: #fff3cd;
			/* Amarillo claro */
			color: #856404;
			/* Amarillo oscuro */
			border-color: #ffeeba;
		}

		.explanation {
			margin-top: 10px;
			font-size: 0.95em;
			color: #555;
			/* Color de texto para la explicación */
		}

		.score-container {
			margin-top: 20px;
			text-align: center;
			display: flex;
			/* Usar flexbox para alinear los botones de puntaje */
			justify-content: center;
			/* Centrar los botones */
			gap: 10px;
			/* Espacio entre los botones */
			flex-wrap: wrap;
			/* Permitir que los botones se envuelvan en pantallas pequeñas */
		}

		.score-button {
			font-size: 1em;
			font-weight: bold;
			padding: 8px 15px;
			/* Padding para que parezcan botones */
			border-radius: 8px;
			/* Bordes redondeados */
			border: none;
			/* Sin borde por defecto */
			color: #ffffff;
			/* Texto blanco */
			display: inline-block;
			/* Para que se muestren en línea */
		}

		.score-button.attempted {
			background-color: #007bff;
			/* Azul para Intentadas */
		}

		.score-button.correct {
			background-color: #28a745;
			/* Verde para Correctas */
		}

		.score-button.incorrect {
			background-color: #ff9800;
			/* Naranja para Incorrectas */
		}


		.button {
			/* Estilo base del botón con Tailwind */
			@apply text-white font-bold py-2 px-4 rounded-lg mt-4 transition duration-300 ease-in-out;
			width: auto;
			/* Ancho automático para que sea más pequeño */
			display: block;
			/* Para que margin: auto funcione */
			margin-left: auto;
			/* Centrar el botón */
			margin-right: auto;
			/* Centrar el botón */
			background-color: #007bff;
			/* Fondo azul */
			color: #ffffff;
			/* Letras blancas */
			border: 2px solid #0056b3;
			/* Añadir un borde azul más oscuro */
			cursor: pointer;
			text-decoration: none;
			/* Asegurarse de que no se vea como enlace */
			padding: 10px 20px;
			/* Ajustar padding para que se vea más como botón */
		}

		.button:disabled {
			@apply bg-gray-400 hover:bg-gray-400 cursor-not-allowed;
			border-color: #6b7280;
			/* Borde gris para botón deshabilitado */
		}

		.button:hover:not(:disabled) {
			background-color: #0056b3;
			/* Azul más oscuro en hover */
			border-color: #003f80;
			/* Borde aún más oscuro en hover */
		}

		/* Estilo para el mensaje final del quiz */
		.quiz-container h2 {
			color: #007bff;
			/* Azul para el título final */
		}


		.timer {
			font-size: 1.5em;
			/* Aumentar tamaño de fuente */
			font-weight: bold;
			color: #ff9800;
			/* Naranja para el temporizador */
			margin-bottom: 15px;
			padding: 10px;
			/* Añadir padding */
			border: 2px solid #ff9800;
			/* Borde naranja */
			border-radius: 8px;
			/* Bordes redondeados */
			display: inline-block;
			/* Para que el borde se ajuste al contenido */
		}

		.end-message {
			margin-top: 20px;
			margin-bottom: 20px;
			font-size: 1.1em;
			color: #333;
		}

		.summary-section {
			margin-top: 30px;
			padding-top: 20px;
			border-top: 1px solid #eee;
			/* Línea separadora */
			text-align: left;
			/* Alinear resumen a la izquierda */
		}

		.summary-section h3 {
			font-size: 1.2em;
			font-weight: bold;
			margin-bottom: 15px;
			color: #007bff;
			/* Azul para el título del resumen */
			text-align: center;
			/* Centrar título del resumen */
		}

		.summary-item {
			margin-bottom: 20px;
			padding: 15px;
			background-color: #f9f9f9;
			/* Fondo ligeramente gris para cada item */
			border-radius: 8px;
			border: 1px solid #eee;
		}

		.summary-item strong {
			color: #333;
			/* Color oscuro para el texto de la pregunta */
		}

		.summary-item .correct-answer {
			margin-top: 5px;
			font-weight: bold;
			color: #155724;
			/* Verde oscuro para la respuesta correcta */
		}

		.summary-item .explanation {
			margin-top: 5px;
			font-size: 0.9em;
			color: #555;
			/* Color de texto para la explicación */
		}
	</style>
</head>

<body>

	<div class="quiz-container">
		<h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Quiz: R, R Markdown, Quarto y Shiny</h1>

		<div class="timer" id="timer-area">Tiempo restante: 60s</div>

		<div id="quiz-content">
			<div id="question-area">
				<div class="question" id="question-text"></div>
				<div class="options" id="options-area">
				</div>
			</div>

			<button id="submit-answer" class="button">Responder</button>
			<button id="next-question" class="button hidden">Siguiente pregunta</button>

			<div id="feedback-area" class="feedback hidden">
			</div>
		</div>

		<div class="score-container" id="score-area">
		</div>

		<div id="end-screen" class="hidden">
			<button id="restart-quiz" class="button hidden">Reiniciar prueba</button>
		</div>

	</div>

	<script>
		// Array de objetos para almacenar las preguntas, opciones, respuestas correctas y explicaciones.
		// Basado en el contenido proporcionado por el usuario.
		const originalQuizData = [ // Mantener una copia original para reiniciar
			{
				question: "¿Cuál es la función principal del menú 'Publish' en el contexto de R Markdown o Quarto?",
				options: {
					A: "Ejecutar todos los chunks de código del documento.",
					B: "Formatear automáticamente el código fuente del documento.",
					C: "Compartir el documento renderizado en servicios online como RPubs.",
					D: "Guardar el documento en un formato específico como PDF o Word."
				},
				correctAnswer: "C",
				explanation: "La función del menú Publish es precisamente permitir a los usuarios compartir sus documentos renderizados en servicios en línea como RPubs, lo que simplifica la difusión de análisis y resultados a una audiencia más amplia."
			},
			{
				question: "¿Qué indica el botón 'Outline' en el editor de R Markdown o Quarto y cómo se activa?",
				options: {
					A: "Indica los errores de sintaxis en el código R; se activa al guardar el archivo.",
					B: "Muestra una vista previa del documento final renderizado; se activa con CTRL+Enter.",
					C: "Indica la estructura de carpetas del proyecto; se activa en el menú 'File'.",
					D: "Muestra un esquema navegable del documento basado en encabezados Markdown; se activa haciendo clic en su botón en la interfaz."
				},
				correctAnswer: "D",
				explanation: "El botón Outline muestra un esquema navegable del documento, construido a partir de los encabezados formateados con Markdown. Se activa simplemente haciendo clic en el botón correspondiente en la interfaz del editor, facilitando la navegación y comprensión de la estructura."
			},
			{
				question: "Describe la función de los botones 'Source' y 'Visual' en el editor.",
				options: {
					A: "'Source' es para ver el código R y 'Visual' es para ver los gráficos generados.",
					B: "'Source' es para editar archivos de datos y 'Visual' es para editar el texto.",
					C: "Permiten alternar entre la vista del código fuente Markdown y una vista WYSIWYG (Lo que ves es lo que obtienes) más amigable para la edición.",
					D: "'Source' compila el documento y 'Visual' lo abre en el navegador."
				},
				correctAnswer: "C",
				explanation: "Los botones Source y Visual son fundamentales para la edición, permitiendo alternar fácilmente entre la manipulación directa del código fuente Markdown y una vista más visual y amigable (WYSIWYG), adaptándose a diferentes preferencias de edición."
			},
			{
				question: "¿Cómo se genera un documento final (renderizado) en R Markdown o Quarto, y qué opciones de formato de salida existen?",
				options: {
					A: "Se utiliza el comando render() en la consola de R; solo se puede generar HTML por defecto.",
					B: "Se guarda el archivo y se utiliza el botón 'Knit' o 'Render'; solo se pueden generar PDF y Word.",
					C: "Se ejecuta el código R del documento; el formato de salida es siempre texto plano.",
					D: "Se guarda el archivo y se utiliza el icono de 'renderizado', pudiendo elegir formatos como HTML, PDF o Word (especificados en YAML), con PDF requiriendo LaTeX."
				},
				correctAnswer: "D",
				explanation: "Para generar el documento final, se guarda el archivo y se usa el icono de renderizado. El triángulo junto a él permite elegir formatos de salida como HTML, PDF o Word, siempre que estén definidos en el encabezado YAML. Es importante recordar que PDF requiere la instalación de LaTeX."
			},
			{
				question: "¿Qué es un chunk en R Markdown o Quarto y cuál es su propósito principal?",
				options: {
					A: "Es una sección de texto narrativo con formato especial.",
					B: "Es un bloque de configuración inicial del documento (YAML).",
					C: "Es un bloque de código R incrustado, delimitado por marcadores, cuyo propósito es ejecutar código y mostrar sus resultados en el documento.",
					D: "Es un enlace a un recurso externo o una imagen."
				},
				correctAnswer: "C",
				explanation: "Un chunk es la parte central de la reproducibilidad: un bloque de código R (u otro lenguaje en Quarto) delimitado por ```{r} y ``` que se ejecuta durante el renderizado para incluir los resultados (código, texto, tablas, gráficos) directamente en el documento final."
			},
			{
				question: "Menciona dos formas de insertar un nuevo chunk de código en el editor.",
				options: {
					A: "Copiar y pegar un chunk existente; usar el menú 'Edit'.",
					B: "Escribir manualmente los delimitadores ``` y {r}; usar la consola de R.",
					C: "Usar el atajo de teclado CTRL+ALT+I; hacer clic en el icono 'Insert a new code chunk' en la barra de herramientas.",
					D: "Usar el menú 'Tools'; arrastrar y soltar un script R."
				},
				correctAnswer: "C",
				explanation: "Las dos formas más directas y eficientes de insertar un chunk son mediante el atajo de teclado universal CTRL+ALT+I o haciendo clic en el icono dedicado ('Insert a new code chunk') en la barra de herramientas del editor."
			},
			{
				question: "¿Qué diferencia existe entre las opciones de chunk echo: false e include: false?",
				options: {
					A: "echo: false oculta los resultados del código, mientras que include: false oculta solo el código fuente.",
					B: "echo: false se usa para texto, include: false se usa para código.",
					C: "echo: false ejecuta el código pero oculta el código fuente en el documento final; include: false ejecuta el código pero oculta tanto el código fuente como sus resultados.",
					D: "echo: false detiene la ejecución del chunk, mientras que include: false la permite."
				},
				correctAnswer: "C",
				explanation: "La distinción es crucial para controlar qué se muestra en el documento. echo: false es útil cuando quieres mostrar solo el resultado de un cálculo o gráfico sin el código que lo generó. include: false oculta todo del chunk, útil para código que genera objetos que se usan más adelante pero no necesitas mostrar."
			},
			{
				question: "¿Cuál es la función principal del paquete Shiny y cuándo se lanzó su primera versión beta pública?",
				options: {
					A: "Es un paquete para crear informes estáticos y publicarlos en RPubs; lanzado en 2010.",
					B: "Es un paquete para limpiar y transformar datos de manera eficiente; lanzado en 2015.",
					C: "Permite la creación de aplicaciones web interactivas y dashboards directamente desde R; su primera versión beta pública se lanzó en 2013.",
					D: "Es una extensión de R Markdown para generar presentaciones; lanzado en 2018."
				},
				correctAnswer: "C",
				explanation: "Shiny revolucionó la capacidad de los usuarios de R para compartir resultados, permitiendo construir potentes aplicaciones web interactivas y dashboards sin necesidad de conocimientos avanzados de desarrollo web. Su lanzamiento beta en 2013 marcó un hito importante."
			},
			{
				question: "Describe brevemente la separación entre las capas UI (interfaz de usuario) y Server en una aplicación Shiny.",
				options: {
					A: "La capa UI contiene el código R, y la capa Server define el diseño visual.",
					B: "La capa UI maneja la lógica de base de datos, y la capa Server maneja la visualización.",
					C: "Ambas capas contienen el mismo tipo de código R, pero se ejecutan en paralelo.",
					D: "La capa UI define la apariencia y los elementos interactivos (inputs/outputs), mientras que la capa Server contiene la lógica de R que procesa datos y genera las salidas en respuesta a las interacciones."
				},
				correctAnswer: "D",
				explanation: "Esta separación es el corazón de la arquitectura Shiny. UI se encarga de lo que el usuario ve e interactúa (botones, sliders, placeholders para gráficos), mientras que Server es el 'cerebro' que realiza los cálculos, filtra datos, genera gráficos y actualiza los elementos en la UI basándose en la actividad del usuario."
			},
			{
				question: "¿Qué significa el concepto de 'reactividad' en el contexto de Shiny?",
				options: {
					A: "La capacidad de la aplicación para conectarse a diferentes bases de datos.",
					B: "La velocidad con la que el código R se ejecuta en el servidor.",
					C: "La habilidad de la aplicación para generar informes PDF de forma automática.",
					D: "La capacidad de la aplicación para actualizar automáticamente partes de la interfaz de usuario (outputs) en respuesta a cambios en las entradas del usuario (inputs) o datos, sin recargar la página completa."
				},
				correctAnswer: "D",
				explanation: "La reactividad es la característica distintiva de Shiny que permite crear experiencias de usuario dinámicas e interactivas. Los outputs 'reaccionan' a los cambios en los inputs del usuario, actualizándose en tiempo real, lo que facilita la exploración de datos interactiva."
			}
		];

		let shuffledQuizData = []; // Array para almacenar las preguntas aleatorizadas
		let currentQuestionIndex = 0; // Índice de la pregunta actual
		let score = 0; // Puntaje del usuario (solo correctas)
		let timerInterval; // Variable para almacenar el intervalo del temporizador
		const TOTAL_QUIZ_TIME = 60; // Tiempo total en segundos para todo el quiz
		let timeLeft = TOTAL_QUIZ_TIME; // Tiempo restante total del quiz
		let quizActive = true; // Bandera para saber si el quiz está activo

		// Obtener referencias a los elementos del DOM - ¡Ahora dentro de window.onload!
		let questionTextElement;
		let optionsAreaElement;
		let submitButton;
		let nextButton;
		let restartButton;
		let feedbackAreaElement;
		let scoreAttemptedButton; // Botón para Intentadas
		let scoreCorrectButton;   // Botón para Correctas
		let scoreIncorrectButton; // Botón para Incorrectas
		let timerAreaElement;
		let quizContentElement;
		let endScreenElement;
		let scoreContainerElement; // Contenedor de los botones de puntaje


		// Función para mezclar un array (Algoritmo Fisher-Yates (Knuth) Shuffle)
		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]]; // Intercambiar elementos
			}
			return array;
		}

		// Función para mezclar las opciones de un objeto de opciones
		function shuffleOptions(optionsObject) {
			const optionKeys = Object.keys(optionsObject);
			shuffleArray(optionKeys); // Mezclar las claves (A, B, C, D)
			const shuffledOptions = {};
			optionKeys.forEach(key => {
				shuffledOptions[key] = optionsObject[key]; // Reconstruir el objeto con el orden mezclado
			});
			return shuffledOptions;
		}


		// Función para iniciar el temporizador global del quiz
		function startGlobalTimer() {
			timeLeft = TOTAL_QUIZ_TIME; // Reiniciar tiempo total
			timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`; // Mostrar tiempo inicial

			timerInterval = setInterval(() => {
				timeLeft--;
				timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`;

				if (timeLeft <= 0) {
					clearInterval(timerInterval); // Detener el temporizador
					endQuiz(true); // Finalizar el quiz porque el tiempo se agotó
				}
			}, 1000); // Actualizar cada 1 segundo
		}

		// Función para detener el temporizador
		function stopTimer() {
			clearInterval(timerInterval);
		}

		// Función para cargar y mostrar la pregunta actual
		function loadQuestion() {
			if (!quizActive) return; // No cargar pregunta si el quiz no está activo

			// Limpiar área de opciones y feedback
			optionsAreaElement.innerHTML = '';
			feedbackAreaElement.innerHTML = '';
			feedbackAreaElement.classList.add('hidden'); // Ocultar feedback
			feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning'); // Limpiar clases de feedback

			// Asegurarse de que el contenido del quiz esté visible y la pantalla final oculta
			quizContentElement.classList.remove('hidden');
			endScreenElement.classList.add('hidden');
			timerAreaElement.classList.remove('hidden'); // Asegurarse de que el temporizador sea visible
			scoreContainerElement.classList.remove('hidden'); // Asegurarse de que el contenedor de puntaje sea visible


			// Obtener la pregunta actual del array de preguntas aleatorizadas
			const currentQuestion = shuffledQuizData[currentQuestionIndex];

			// Mostrar el texto de la pregunta
			questionTextElement.textContent = currentQuestion.question;

			// Mezclar las opciones de la pregunta actual
			const shuffledOptions = shuffleOptions(currentQuestion.options);

			// Crear y mostrar las opciones de respuesta mezcladas
			for (const optionKey in shuffledOptions) {
				if (shuffledOptions.hasOwnProperty(optionKey)) {
					const optionValue = shuffledOptions[optionKey];

					// Crear un div para cada opción para mejor estructura y padding
					const optionDiv = document.createElement('div');

					const input = document.createElement('input');
					input.type = 'radio';
					input.name = 'answer'; // Mismo nombre para que solo una opción sea seleccionable
					input.value = optionKey;
					input.id = `option-${optionKey}`; // ID único para la etiqueta

					const label = document.createElement('label');
					label.textContent = `${optionKey}) ${optionValue}`;
					label.htmlFor = `option-${optionKey}`; // Asociar etiqueta con input

					// Añadir input y label al div de la opción
					optionDiv.appendChild(input);
					optionDiv.appendChild(label);

					// Añadir el div de la opción al área de opciones
					optionsAreaElement.appendChild(optionDiv);
				}
			}

			// Mostrar el botón de responder y ocultar el de siguiente
			submitButton.classList.remove('hidden');
			nextButton.classList.add('hidden');

			// Habilitar el botón de responder
			submitButton.disabled = false;

			// Actualizar el puntaje mostrado (Intentadas, Correctas, Incorrectas)
			updateScoreDisplay();

			// Deshabilitar opciones si el tiempo se agotó (aunque endQuiz debería manejar esto)
			if (timeLeft <= 0) {
				disableOptions();
				submitButton.disabled = true;
			}
		}

		// Función para deshabilitar las opciones de respuesta
		function disableOptions() {
			const options = optionsAreaElement.querySelectorAll('input[type="radio"]');
			options.forEach(option => {
				option.disabled = true;
			});
		}


		// Función para verificar la respuesta seleccionada
		function checkAnswer() {
			if (!quizActive) return; // No procesar respuesta si el quiz no está activo

			// Obtener la opción seleccionada por el usuario
			const selectedOption = document.querySelector('input[name="answer"]:checked');

			// Deshabilitar el botón de responder para evitar múltiples envíos
			submitButton.disabled = true;
			disableOptions(); // Deshabilitar opciones después de responder

			let userAnswer = null;
			if (selectedOption) {
				userAnswer = selectedOption.value;
			}

			// Obtener la respuesta correcta de la pregunta actual (del array mezclado)
			const correctAnswer = shuffledQuizData[currentQuestionIndex].correctAnswer;
			const explanation = shuffledQuizData[currentQuestionIndex].explanation;

			// Mostrar el área de feedback
			feedbackAreaElement.classList.remove('hidden');

			// Limpiar clases de feedback previas
			feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning');

			// Comprobar si la respuesta es correcta
			if (userAnswer === correctAnswer) {
				score++; // Incrementar puntaje si es correcta
				feedbackAreaElement.classList.add('correct');
				feedbackAreaElement.innerHTML = '<strong>¡Correcto!</strong>';
			} else {
				feedbackAreaElement.classList.add('incorrect');
				feedbackAreaElement.innerHTML = `<strong>Incorrecto.</strong> La respuesta correcta es ${correctAnswer}.`;
			}

			// Añadir la explicación al feedback
			const explanationElement = document.createElement('p');
			explanationElement.classList.add('explanation');
			explanationElement.textContent = explanation;
			feedbackAreaElement.appendChild(explanationElement);

			// Ocultar el botón de responder y mostrar el de siguiente
			submitButton.classList.add('hidden');
			// Solo mostrar el botón siguiente si el tiempo no se ha agotado
			if (timeLeft > 0) {
				nextButton.classList.remove('hidden');
			} else {
				// Si el tiempo se agotó, ir directamente a la pantalla final
				endQuiz(true);
			}


			// Actualizar la visualización del puntaje (después de incrementar el score si fue correcta)
			updateScoreDisplay();
		}

		// Función para pasar a la siguiente pregunta o finalizar el quiz
		function nextQuestion() {
			if (!quizActive) return; // No pasar de pregunta si el quiz no está activo

			currentQuestionIndex++; // Incrementar el índice de la pregunta

			// Verificar si hay más preguntas (en el array mezclado) y si el tiempo no se ha agotado
			if (currentQuestionIndex < shuffledQuizData.length && timeLeft > 0) {
				loadQuestion(); // Cargar la siguiente pregunta
			} else {
				endQuiz(false); // Finalizar el quiz (ya sea por terminar preguntas o por tiempo agotado)
			}
		}

		// Función para actualizar la visualización del puntaje
		function updateScoreDisplay() {
			const attempted = currentQuestionIndex + (quizActive && !submitButton.classList.contains('hidden') && document.querySelector('input[name="answer"]:checked') ? 1 : 0); // Contar la pregunta actual si se ha respondido
			const correct = score;
			const incorrect = attempted - correct;

			// Actualizar el texto de los botones de puntaje
			scoreAttemptedButton.textContent = `Intentadas: ${attempted}`;
			scoreCorrectButton.textContent = `Correctas: ${correct}`;
			scoreIncorrectButton.textContent = `Incorrectas: ${incorrect}`;
		}

		// Función para finalizar el quiz
		function endQuiz(timeRanOut) {
			if (!quizActive) return; // Evitar finalizar múltiples veces
			quizActive = false; // Marcar el quiz como inactivo

			// Detener el temporizador final
			stopTimer();
			timerAreaElement.classList.add('hidden'); // Ocultar el temporizador al finalizar

			// Ocultar el contenido del quiz
			quizContentElement.classList.add('hidden');
			scoreContainerElement.classList.add('hidden'); // Ocultar los botones de puntaje principales


			// Mostrar la pantalla final
			endScreenElement.classList.remove('hidden');

			// Mostrar mensaje de fin de quiz
			const endTitle = document.createElement('h2');
			endTitle.classList.add('text-xl', 'font-bold', 'text-center', 'text-gray-800', 'mb-4');
			if (timeRanOut) {
				endTitle.textContent = '¡Tiempo agotado!';
			} else {
				endTitle.textContent = '¡Quiz Finalizado!';
			}

			// Calcular el puntaje final detallado
			const totalAttempted = currentQuestionIndex; // Total de preguntas que se intentaron
			const finalCorrect = score;
			const finalIncorrect = totalAttempted - finalCorrect;


			// Determinar el mensaje basado en el puntaje
			let scoreMessageText = "";
			if (finalCorrect < 3) {
				scoreMessageText = "Sigue repasando el contenido, cada intento puedes mejorar.";
			} else if (finalCorrect >= 3 && finalCorrect < 5) {
				scoreMessageText = "¡Bien! Estás avanzando por el camino de R, sigue repasando.";
			} else { // finalCorrect >= 5
				scoreMessageText = "¡Sigue así! Estás aprendiendo a trabajar con R.";
			}

			const scoreMessageElement = document.createElement('p');
			scoreMessageElement.classList.add('end-message', 'text-center');
			scoreMessageElement.textContent = scoreMessageText;

			// Crear un nuevo contenedor para los botones de puntaje finales
			const finalScoreContainer = document.createElement('div');
			finalScoreContainer.classList.add('score-container'); // Reutilizar la clase de estilo


			// Crear y añadir los botones de puntaje finales
			const finalAttemptedButton = document.createElement('span');
			finalAttemptedButton.classList.add('score-button', 'attempted');
			finalAttemptedButton.textContent = `Intentadas: ${totalAttempted}`;
			finalScoreContainer.appendChild(finalAttemptedButton);

			const finalCorrectButton = document.createElement('span');
			finalCorrectButton.classList.add('score-button', 'correct');
			finalCorrectButton.textContent = `Correctas: ${finalCorrect}`;
			finalScoreContainer.appendChild(finalCorrectButton);

			const finalIncorrectButton = document.createElement('span');
			finalIncorrectButton.classList.add('score-button', 'incorrect');
			finalIncorrectButton.textContent = `Incorrectas: ${finalIncorrect}`;
			finalScoreContainer.appendChild(finalIncorrectButton);


			// Limpiar el contenido anterior de la pantalla final y añadir los nuevos elementos
			endScreenElement.innerHTML = '';
			endScreenElement.appendChild(endTitle);
			endScreenElement.appendChild(finalScoreContainer); // Añadir el contenedor de botones de puntaje finales
			endScreenElement.appendChild(scoreMessageElement); // Añadir el mensaje basado en el puntaje

			// --- Agregar la sección de resumen de preguntas respondidas ---
			const summarySection = document.createElement('div');
			summarySection.classList.add('summary-section');

			const summaryTitle = document.createElement('h3');
			summaryTitle.textContent = 'Resumen de Preguntas Respondidas';
			summarySection.appendChild(summaryTitle);

			// Iterar solo sobre las preguntas que fueron presentadas en este quiz
			// currentQuestionIndex es el índice de la *siguiente* pregunta a mostrar,
			// por lo que iteramos desde 0 hasta currentQuestionIndex - 1.
			for (let i = 0; i < currentQuestionIndex; i++) {
				const questionData = shuffledQuizData[i]; // Obtener la pregunta del array mezclado

				const summaryItem = document.createElement('div');
				summaryItem.classList.add('summary-item');

				const questionText = document.createElement('p');
				questionText.innerHTML = `<strong>Pregunta ${i + 1}:</strong> ${questionData.question}`; // Usar i+1 para el número de pregunta en el resumen
				summaryItem.appendChild(questionText);

				const correctAnswer = document.createElement('p');
				// Encontrar el texto de la respuesta correcta usando la clave
				const correctAnswerText = questionData.options[questionData.correctAnswer];
				correctAnswer.innerHTML = `<span class="correct-answer">Respuesta Correcta: ${questionData.correctAnswer}) ${correctAnswerText}</span>`;
				summaryItem.appendChild(correctAnswer);

				const explanation = document.createElement('p');
				explanation.classList.add('explanation');
				explanation.textContent = `Explicación: ${questionData.explanation}`;
				summaryItem.appendChild(explanation);

				summarySection.appendChild(summaryItem);
			}


			endScreenElement.appendChild(summarySection); // Añadir la sección de resumen a la pantalla final
			// --- Fin de la sección de resumen ---


			// Mostrar el botón de reiniciar
			restartButton.classList.remove('hidden');
			endScreenElement.appendChild(restartButton); // Añadir el botón de reiniciar a la pantalla final

			// Asegurarse de que el área de puntaje principal esté oculta al mostrar el puntaje final en la pantalla final
			// scoreAreaElement.classList.add('hidden'); // Esto ya no es necesario ya que ocultamos scoreContainerElement
		}

		// Función para reiniciar el quiz
		function restartQuiz() {
			currentQuestionIndex = 0; // Reiniciar índice de pregunta
			score = 0; // Reiniciar puntaje
			quizActive = true; // Marcar el quiz como activo

			// Mezclar las preguntas nuevamente al reiniciar
			shuffledQuizData = shuffleArray([...originalQuizData]); // Usar una copia del array original

			// Reiniciar la visualización del puntaje antes de cargar la primera pregunta
			scoreAttemptedButton.textContent = `Intentadas: 0`;
			scoreCorrectButton.textContent = `Correctas: 0`;
			scoreIncorrectButton.textContent = `Incorrectas: 0`;


			loadQuestion(); // Cargar la primera pregunta
			startGlobalTimer(); // Iniciar el temporizador global

			// Ocultar la pantalla final al iniciar un nuevo quiz
			endScreenElement.classList.add('hidden');
			// Asegurarse de que el contenido del quiz esté visible
			quizContentElement.classList.remove('hidden');
			// Asegurarse de que el contenedor de puntaje principal sea visible
			scoreContainerElement.classList.remove('hidden');
		}


		// Este código se ejecutará una vez que toda la página HTML esté completamente cargada
		window.onload = () => {
			// Obtener referencias a los elementos del DOM
			questionTextElement = document.getElementById('question-text');
			optionsAreaElement = document.getElementById('options-area');
			submitButton = document.getElementById('submit-answer');
			nextButton = document.getElementById('next-question');
			restartButton = document.getElementById('restart-quiz'); // Obtener referencia al botón de reiniciar
			feedbackAreaElement = document.getElementById('feedback-area');
			scoreContainerElement = document.getElementById('score-area'); // Referencia al contenedor
			timerAreaElement = document.getElementById('timer-area');
			quizContentElement = document.getElementById('quiz-content');
			endScreenElement = document.getElementById('end-screen');

			// Crear los elementos para los botones de puntaje
			scoreAttemptedButton = document.createElement('span');
			scoreAttemptedButton.classList.add('score-button', 'attempted');
			scoreContainerElement.appendChild(scoreAttemptedButton);

			scoreCorrectButton = document.createElement('span');
			scoreCorrectButton.classList.add('score-button', 'correct');
			scoreContainerElement.appendChild(scoreCorrectButton);

			scoreIncorrectButton = document.createElement('span');
			scoreIncorrectButton.classList.add('score-button', 'incorrect');
			scoreContainerElement.appendChild(scoreIncorrectButton);


			// Event listeners para los botones - ¡Ahora dentro de window.onload!
			submitButton.addEventListener('click', checkAnswer);
			nextButton.addEventListener('click', nextQuestion);
			restartButton.addEventListener('click', restartQuiz); // Event listener para el botón de reiniciar

			// Mezclar las preguntas al cargar la página por primera vez
			shuffledQuizData = shuffleArray([...originalQuizData]); // Usar una copia del array original

			// Iniciar el temporizador global y cargar la primera pregunta al iniciar la página
			startGlobalTimer(); // Iniciar el temporizador global
			loadQuestion(); // Cargar la primera pregunta
		};

	</script>

</body>

</html>