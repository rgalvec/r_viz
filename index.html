<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quiz: R, R Markdown, Quarto y Shiny</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
		/* Estilos base para el modo claro */
		body {
			font-family: "Inter", sans-serif;
			background-color: #f4f7f6;
			color: #333;
			/* Texto oscuro por defecto */
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 100vh;
			padding: 20px;
			transition: background-color 0.3s ease, color 0.3s ease;
			/* Transici칩n suave para cambio de modo */
		}

		.quiz-container {
			background-color: #ffffff;
			/* Fondo blanco */
			padding: 30px;
			border-radius: 15px;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			max-width: 700px;
			width: 100%;
			text-align: center;
			position: relative;
			/* Necesario para posicionar el bot칩n de modo oscuro */
			transition: background-color 0.3s ease, box-shadow 0.3s ease;
			/* Transici칩n suave */
		}

		.question {
			margin-bottom: 20px;
			font-size: 1.1em;
			font-weight: bold;
			color: #333;
			text-align: left;
		}

		.options {
			text-align: left;
		}

		.options label {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color 0.3s ease, border-color 0.3s ease;
			position: relative;
			padding-left: 35px;
			color: #333;
			/* Color de texto por defecto */
		}

		.options label:hover {
			background-color: #ffeacc;
			/* Naranja claro para hover */
			border-color: #ff9800;
			/* Naranja para el borde en hover */
		}

		/* Ocultar el radio button nativo */
		.options input[type="radio"] {
			position: absolute;
			opacity: 0;
			cursor: pointer;
			height: 0;
			width: 0;
		}

		/* Crear el cuadrado personalizado */
		.options label::before {
			content: '';
			position: absolute;
			left: 10px;
			top: 50%;
			transform: translateY(-50%);
			width: 20px;
			height: 20px;
			border: 2px solid #007bff;
			border-radius: 4px;
			background-color: #fff;
			transition: all 0.3s ease;
		}

		/* Estilo para el cuadrado cuando el radio button est치 seleccionado */
		.options input[type="radio"]:checked+label::before {
			background-color: #007bff;
			border-color: #007bff;
		}

		/* Estilo para el punto interior del cuadrado */
		.options label::after {
			content: '';
			position: absolute;
			left: 16px;
			top: 50%;
			transform: translateY(-50%);
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background-color: #fff;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		/* Mostrar el punto interior cuando el radio button est치 seleccionado */
		.options input[type="radio"]:checked+label::after {
			opacity: 1;
		}


		.feedback {
			margin-top: 20px;
			padding: 15px;
			border-radius: 8px;
			text-align: left;
		}

		.feedback.correct {
			background-color: #d4edda;
			color: #155724;
			border-color: #c3e6cb;
		}

		.feedback.incorrect {
			background-color: #f8d7da;
			color: #721c24;
			border-color: #f5c6cb;
		}

		.feedback.warning {
			background-color: #fff3cd;
			color: #856404;
			border-color: #ffeeba;
		}

		.explanation {
			margin-top: 10px;
			font-size: 0.95em;
			color: #555;
		}

		.score-container {
			margin-top: 20px;
			text-align: center;
			display: flex;
			justify-content: center;
			gap: 10px;
			flex-wrap: wrap;
		}

		.score-button {
			font-size: 1em;
			font-weight: bold;
			padding: 8px 15px;
			border-radius: 8px;
			border: none;
			color: #ffffff;
			display: inline-block;
		}

		.score-button.attempted {
			background-color: #007bff;
			/* Azul para Intentadas */
		}

		.score-button.correct {
			background-color: #28a745;
			/* Verde para Correctas */
		}

		.score-button.incorrect {
			background-color: #ff9800;
			/* Naranja para Incorrectas */
		}


		.button {
			@apply text-white font-bold py-2 px-4 rounded-lg mt-4 transition duration-0;
			/* Transici칩n m치s r치pida */
			width: auto;
			display: block;
			margin-left: auto;
			margin-right: auto;
			background-color: #007bff;
			color: #ffffff;
			border: 2px solid #0056b3;
			cursor: pointer;
			text-decoration: none;
			padding: 10px 20px;
		}

		.button:disabled {
			@apply bg-gray-400 hover:bg-gray-400 cursor-not-allowed;
			border-color: #6b7280;
		}

		.button:hover:not(:disabled) {
			background-color: #0056b3;
			border-color: #003f80;
		}

		/* Estilo para el mensaje final del quiz */
		.quiz-container h2 {
			color: #007bff;
		}


		.timer {
			font-size: 1.5em;
			font-weight: bold;
			color: #ff9800;
			margin-bottom: 15px;
			padding: 10px;
			border: 2px solid #ff9800;
			border-radius: 8px;
			display: inline-block;
		}

		.end-message {
			margin-top: 20px;
			margin-bottom: 20px;
			font-size: 1.1em;
			color: #333;
		}

		.summary-section {
			margin-top: 30px;
			padding-top: 20px;
			border-top: 1px solid #eee;
			text-align: left;
		}

		body.dark-mode .summary-section {
			border-top-color: #4a5568;
			/* Borde separador oscuro */
		}


		.summary-section h3 {
			font-size: 1.2em;
			font-weight: bold;
			margin-bottom: 15px;
			color: #007bff;
			text-align: center;
		}

		body.dark-mode .summary-section h3 {
			color: #007bff;
			/* Azul para t칤tulo del resumen */
		}

		.summary-item {
			margin-bottom: 20px;
			padding: 15px;
			background-color: #f9f9f9;
			border-radius: 8px;
			border: 1px solid #eee;
		}

		body.dark-mode .summary-item {
			background-color: #2d3748;
			border-color: #4a5568;
		}


		.summary-item strong {
			color: #333;
		}

		body.dark-mode .summary-item strong {
			color: #e2e8f0;
			/* Texto de pregunta claro */
		}


		.summary-item .correct-answer {
			margin-top: 5px;
			font-weight: bold;
			color: #155724;
		}

		body.dark-mode .summary-item .correct-answer {
			color: #48bb78;
			/* Verde en modo oscuro */
		}


		.summary-item .explanation {
			margin-top: 5px;
			font-size: 0.9em;
			color: #555;
		}

		body.dark-mode .summary-item .explanation {
			color: #cbd5e0;
			/* Texto de explicaci칩n claro */
		}


		/* Estilos para el modo oscuro */
		body.dark-mode {
			background-color: #1a202c;
			/* Fondo oscuro */
			color: #e2e8f0;
			/* Texto claro */
		}

		body.dark-mode .quiz-container {
			background-color: #2d3748;
			/* Fondo oscuro para el contenedor */
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
		}

		body.dark-mode h1 {
			/* Ajustar color del t칤tulo principal en modo oscuro */
			color: #e2e8f0;
		}

		body.dark-mode .question {
			color: #e2e8f0;
			/* Texto de pregunta claro */
		}

		body.dark-mode .options label {
			border-color: #4a5568;
			/* Borde m치s oscuro */
			color: #e2e8f0;
			/* Texto de opci칩n claro */
		}

		body.dark-mode .options label:hover {
			background-color: #4a5568;
			/* Fondo oscuro en hover */
			border-color: #007bff;
			/* Borde azul en hover */
		}

		body.dark-mode .options label::before {
			border-color: #007bff;
			/* Borde azul */
			background-color: #2d3748;
			/* Fondo oscuro */
		}

		body.dark-mode .options input[type="radio"]:checked+label::before {
			background-color: #007bff;
			/* Fondo azul seleccionado */
			border-color: #007bff;
		}

		body.dark-mode .options label::after {
			background-color: #e2e8f0;
			/* Punto interior claro */
		}

		body.dark-mode .feedback.correct {
			background-color: #48bb78;
			/* Verde m치s oscuro */
			color: #1a202c;
			/* Texto oscuro */
			border-color: #38a169;
		}

		body.dark-mode .feedback.incorrect {
			background-color: #f56565;
			/* Rojo m치s oscuro */
			color: #1a202c;
			/* Texto oscuro */
			border-color: #e53e3e;
		}

		body.dark-mode .feedback.warning {
			background-color: #f6e05e;
			/* Amarillo m치s oscuro */
			color: #2d3748;
			/* Texto oscuro */
			border-color: #d69e2e;
		}

		body.dark-mode .explanation {
			color: #cbd5e0;
			/* Texto de explicaci칩n claro */
		}

		body.dark-mode .quiz-container h2 {
			color: #007bff;
			/* Azul para t칤tulo final */
		}

		body.dark-mode .quiz-container .score-button.attempted {
			background-color: #007bff;
			/* Azul para Intentadas */
		}

		body.dark-mode .quiz-container .score-button.correct {
			background-color: #48bb78;
			/* Verde en modo oscuro */
		}

		body.dark-mode .quiz-container .score-button.incorrect {
			background-color: #ff9800;
			/* Naranja en modo oscuro */
		}

		body.dark-mode .timer {
			color: #ff9800;
			/* Naranja para el temporizador */
			border-color: #ff9800;
		}

		body.dark-mode .end-message {
			color: #e2e8f0;
			/* Texto claro */
		}

		body.dark-mode .summary-section {
			border-top-color: #4a5568;
			/* Borde separador oscuro */
		}

		body.dark-mode .summary-section h3 {
			color: #007bff;
			/* Azul para t칤tulo del resumen */
		}

		body.dark-mode .summary-item {
			background-color: #2d3748;
			/* Fondo oscuro */
			border-color: #4a5568;
			/* Borde oscuro */
		}

		body.dark-mode .summary-item strong {
			color: #e2e8f0;
			/* Texto de pregunta claro */
		}

		body.dark-mode .summary-item .correct-answer {
			color: #48bb78;
			/* Verde en modo oscuro */
		}

		body.dark-mode .summary-item .explanation {
			color: #cbd5e0;
			/* Texto de explicaci칩n claro */
		}

		/* Estilo para el bot칩n de modo oscuro */
		#dark-mode-toggle {
			position: absolute;
			top: 15px;
			right: 15px;
			background-color: #007bff;
			/* Fondo azul */
			color: white;
			border: none;
			border-radius: 50%;
			/* Bot칩n redondo */
			width: 35px;
			height: 35px;
			font-size: 1em;
			cursor: pointer;
			display: flex;
			justify-content: center;
			align-items: center;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			transition: background-color 0.3s ease, transform 0.2s ease;
			z-index: 10;
			/* Asegurar que est칠 por encima de otros elementos */
		}

		#dark-mode-toggle:hover {
			background-color: #0056b3;
			/* Azul m치s oscuro en hover */
			transform: scale(1.05);
		}

		body.dark-mode #dark-mode-toggle {
			background-color: #007bff;
			/* Mantener azul en modo oscuro */
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
		}

		body.dark-mode #dark-mode-toggle:hover {
			background-color: #0056b3;
			/* Mantener azul m치s oscuro en hover */
		}

		/* Estilos para las pesta침as */
		.tabs {
			display: flex;
			margin-bottom: 20px;
			border-bottom: 1px solid #ddd;
		}

		body.dark-mode .tabs {
			border-bottom-color: #4a5568;
		}

		.tab-button {
			padding: 10px 20px;
			cursor: pointer;
			border: none;
			background-color: transparent;
			font-size: 1.1em;
			font-weight: bold;
			color: #555;
			border-bottom: 2px solid transparent;
			transition: color 0.3s ease, border-bottom-color 0.3s ease;
		}

		body.dark-mode .tab-button {
			color: #b0b0b0;
		}

		.tab-button:hover {
			color: #007bff;
			border-bottom-color: #007bff;
		}

		body.dark-mode .tab-button:hover {
			color: #007bff;
			border-bottom-color: #007bff;
		}


		.tab-button.active {
			color: #007bff;
			border-bottom-color: #007bff;
		}

		body.dark-mode .tab-button.active {
			color: #007bff;
			border-bottom-color: #007bff;
		}


		.tab-content {
			display: none;
			/* Ocultar contenido de pesta침a por defecto */
			padding-top: 20px;
		}

		.tab-content.active {
			display: block;
			/* Mostrar contenido de la pesta침a activa */
		}


		/* Mensaje de usabilidad para el progreso */
		.usability-message {
			font-size: 0.85em;
			color: #555;
			margin-top: 20px;
			text-align: center;
		}

		body.dark-mode .usability-message {
			color: #b0b0b0;
			/* Gris claro */
		}

		/* Contenedor para el historial de sesiones */
		.session-history-container {
			margin-top: 30px;
			padding-top: 20px;
			border-top: 1px solid #eee;
			text-align: left;
		}

		body.dark-mode .session-history-container {
			border-top-color: #424242;
		}

		.session-history-container h3 {
			font-size: 1.2em;
			font-weight: bold;
			margin-bottom: 15px;
			color: #007bff;
			text-align: center;
		}

		body.dark-mode .session-history-container h3 {
			color: #007bff;
			/* Azul */
		}

		.session-item {
			margin-bottom: 15px;
			padding: 15px;
			background-color: #f9f9f9;
			border-radius: 8px;
			border: 1px solid #eee;
		}

		body.dark-mode .session-item {
			background-color: #2d2d2d;
			border-color: #424242;
		}

		.session-item p {
			margin-bottom: 5px;
			color: #333;
		}

		body.dark-mode .session-item p {
			color: #e0e0e0;
			/* Texto claro */
		}

		.session-item .score-detail {
			font-size: 0.95em;
			color: #555;
		}

		body.dark-mode .session-item .score-detail {
			color: #b0b0b0;
			/* Gris claro */
		}

		/* Estilos para el 치rea del gr치fico */
		.progress-chart-container {
			margin-top: 30px;
			padding-top: 20px;
			border-top: 1px solid #eee;
			text-align: center;
		}

		body.dark-mode .progress-chart-container {
			border-top-color: #424242;
		}

		.progress-chart-container h3 {
			font-size: 1.2em;
			font-weight: bold;
			margin-bottom: 15px;
			color: #007bff;
		}

		body.dark-mode .progress-chart-container h3 {
			color: #007bff;
			/* Azul */
		}

		.progress-chart-container svg {
			background-color: #f9f9f9;
			/* Fondo claro para el gr치fico */
			border-radius: 8px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
		}

		body.dark-mode .progress-chart-container svg {
			background-color: #2d2d2d;
			/* Fondo oscuro para el gr치fico */
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		.progress-chart-container .axis text {
			font-size: 0.8em;
			fill: #333;
			/* Color de texto del eje */
		}

		body.dark-mode .progress-chart-container .axis text {
			fill: #e0e0e0;
			/* Color de texto del eje en modo oscuro */
		}

		.progress-chart-container .axis path,
		.progress-chart-container .axis line {
			stroke: #888;
			/* Color de las l칤neas del eje */
		}

		body.dark-mode .progress-chart-container .axis path,
		body.dark-mode .progress-chart-container .axis line {
			stroke: #b0b0b0;
			/* Color de las l칤neas del eje en modo oscuro */
		}

		.progress-chart-container .correct-bar {
			fill: #4caf50;
			/* Verde para barras correctas */
		}

		.progress-chart-container .incorrect-bar {
			fill: #ff9800;
			/* Naranja para barras incorrectas */
		}

		.progress-chart-container .tooltip {
			position: absolute;
			text-align: center;
			padding: 8px;
			font: 12px sans-serif;
			background: lightsteelblue;
			border: 0px;
			border-radius: 8px;
			pointer-events: none;
			color: #333;
			z-index: 100;
			/* Asegurar que el tooltip est칠 por encima */
		}
	</style>
</head>

<body>

	<div class="quiz-container">
		<button id="dark-mode-toggle">游깿</button>
		<h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Quiz: R, R Markdown, Quarto y Shiny</h1>

		<div class="tabs">
			<button class="tab-button active" data-tab="quiz-tab">Quiz</button>
			<button class="tab-button" data-tab="progress-tab">Progreso</button>
		</div>

		<div id="quiz-tab" class="tab-content active">
			<div class="timer" id="timer-area">Tiempo restante: 60s</div>

			<div id="quiz-content">
				<div id="question-area">
					<div class="question" id="question-text"></div>
					<div class="options" id="options-area">
					</div>
				</div>

				<button id="submit-answer" class="button">Responder</button>
				<button id="next-question" class="button hidden">Siguiente pregunta</button>

				<div id="feedback-area" class="feedback hidden">
				</div>
			</div>

			<div class="score-container" id="score-area">
			</div>

			<div id="end-screen" class="hidden">
				<button id="restart-quiz" class="button hidden">Reiniciar prueba</button>
			</div>
		</div>

		<div id="progress-tab" class="tab-content">
			<div class="session-history-container">
				<h3 id="session-history-title">Historial de Sesi칩n</h3>
				<div id="session-history-list">
				</div>
				<button id="clear-history-button" class="button">Borrar Historial</button>
				<p class="usability-message">Tu progreso se guarda en tu navegador hasta que borres el historial o uses
					otro dispositivo.</p>
			</div>

			<div class="progress-chart-container hidden">
				<h3>Progreso de Intentos</h3>
				<div id="progress-chart">
				</div>
			</div>
		</div>


	</div>

	<script>
		// Array de objetos para almacenar las preguntas, opciones, respuestas correctas y explicaciones.
		// Basado en el contenido proporcionado por el usuario.
		const originalQuizData = [ // Mantener una copia original para reiniciar
			{
				question: "쮺u치l es la funci칩n principal del men칰 'Publish' en el contexto de R Markdown o Quarto?",
				options: {
					A: "Ejecutar todos los chunks de c칩digo del documento.",
					B: "Formatear autom치ticamente el c칩digo fuente del documento.",
					C: "Compartir el documento renderizado en servicios online como RPubs.",
					D: "Guardar el documento en un formato espec칤fico como PDF o Word."
				},
				correctAnswer: "C",
				explanation: "La funci칩n del men칰 Publish es precisamente permitir a los usuarios compartir sus documentos renderizados en servicios en l칤nea como RPubs, lo que simplifica la difusi칩n de an치lisis y resultados a una audiencia m치s amplia."
			},
			{
				question: "쯈u칠 indica el bot칩n 'Outline' en el editor de R Markdown o Quarto y c칩mo se activa?",
				options: {
					A: "Indica los errores de sintaxis en el c칩digo R; se activa al guardar el archivo.",
					B: "Muestra una vista previa del documento final renderizado; se activa con CTRL+Enter.",
					C: "Indica la estructura de carpetas del proyecto; se activa en el men칰 'File'.",
					D: "Muestra un esquema navegable del documento basado en encabezados Markdown; se activa haciendo clic en su bot칩n en la interfaz."
				},
				correctAnswer: "D",
				explanation: "El bot칩n Outline muestra un esquema navegable del documento, construido a partir de los encabezados formateados con Markdown. Se activa simplemente haciendo clic en el bot칩n correspondiente en la interfaz del editor, facilitando la navegaci칩n y comprensi칩n de la estructura."
			},
			{
				question: "Describe la funci칩n de los botones 'Source' y 'Visual' en el editor.",
				options: {
					A: "'Source' es para ver el c칩digo R y 'Visual' es para ver los gr치ficos generados.",
					B: "'Source' es para editar archivos de datos y 'Visual' es para editar el texto.",
					C: "Permiten alternar entre la vista del c칩digo fuente Markdown y una vista WYSIWYG (Lo que ves es lo que obtienes) m치s amigable para la edici칩n.",
					D: "'Source' compila el documento y 'Visual' lo abre en el navegador."
				},
				correctAnswer: "C",
				explanation: "Los botones Source y Visual son fundamentales para la edici칩n, permitiendo alternar f치cilmente entre la manipulaci칩n directa del c칩digo fuente Markdown y una vista m치s visual y amigable (WYSIWYG), adapt치ndose a diferentes preferencias de edici칩n."
			},
			{
				question: "쮺칩mo se genera un documento final (renderizado) en R Markdown o Quarto, y qu칠 opciones de formato de salida existen?",
				options: {
					A: "Se utiliza el comando render() en la consola de R; solo se puede generar HTML por defecto.",
					B: "Se guarda el archivo y se utiliza el bot칩n 'Knit' o 'Render'; solo se pueden generar PDF y Word.",
					C: "Se ejecuta el c칩digo R del documento; el formato de salida es siempre texto plano.",
					D: "Se guarda el archivo y se utiliza el icono de 'renderizado', pudiendo elegir formatos como HTML, PDF o Word (especificados en YAML), con PDF requiriendo LaTeX."
				},
				correctAnswer: "D",
				explanation: "Para generar el documento final, se guarda el archivo y se usa el icono de renderizado. El tri치ngulo junto a 칠l permite elegir formatos de salida como HTML, PDF o Word, siempre que est칠n definidos en el encabezado YAML. Es importante recordar que PDF requiere la instalaci칩n de LaTeX."
			},
			{
				question: "쯈u칠 es un chunk en R Markdown o Quarto y cu치l es su prop칩sito principal?",
				options: {
					A: "Es una secci칩n de texto narrativo con formato especial.",
					B: "Es un bloque de configuraci칩n inicial del documento (YAML).",
					C: "Es un bloque de c칩digo R incrustado, delimitado por marcadores, cuyo prop칩sito es ejecutar c칩digo y mostrar sus resultados en el documento.",
					D: "Es un enlace a un recurso externo o una imagen."
				},
				correctAnswer: "C",
				explanation: "Un chunk es la parte central de la reproducibilidad: un bloque de c칩digo R (u otro lenguaje en Quarto) delimitado por ```{r} y ``` que se ejecuta durante el renderizado para incluir los resultados (c칩digo, texto, tablas, gr치ficos) directamente en el documento final."
			},
			{
				question: "Menciona dos formas de insertar un nuevo chunk de c칩digo en el editor.",
				options: {
					A: "Copiar y pegar un chunk existente; usar el men칰 'Edit'.",
					B: "Escribir manualmente los delimitadores ``` y {r}; usar la consola de R.",
					C: "Usar el atajo de teclado CTRL+ALT+I; hacer clic en el icono 'Insert a new code chunk' en la barra de herramientas.",
					D: "Usar el men칰 'Tools'; arrastrar y soltar un script R."
				},
				correctAnswer: "C",
				explanation: "Las dos formas m치s directas y eficientes de insertar un chunk son mediante el atajo de teclado universal CTRL+ALT+I o haciendo clic en el icono dedicado ('Insert a new code chunk') en la barra de herramientas del editor."
			},
			{
				question: "쯈u칠 diferencia existe entre las opciones de chunk echo: false e include: false?",
				options: {
					A: "echo: false oculta los resultados del c칩digo, mientras que include: false oculta solo el c칩digo fuente.",
					B: "echo: false se usa para texto, include: false se usa para c칩digo.",
					C: "echo: false ejecuta el c칩digo pero oculta el c칩digo fuente en el documento final; include: false ejecuta el c칩digo pero oculta tanto el c칩digo fuente como sus resultados.",
					D: "echo: false detiene la ejecuci칩n del chunk, mientras que include: false la permite."
				},
				correctAnswer: "C",
				explanation: "La distinci칩n es crucial para controlar qu칠 se muestra en el documento. echo: false es 칰til cuando quieres mostrar solo el resultado de un c치lculo o gr치fico sin el c칩digo que lo gener칩. include: false oculta todo del chunk, 칰til para c칩digo que genera objetos que se usan m치s adelante pero no necesitas mostrar."
			},
			{
				question: "쮺u치l es la funci칩n principal del paquete Shiny y cu치ndo se lanz칩 su primera versi칩n beta p칰blica?",
				options: {
					A: "Es un paquete para crear informes est치ticos y publicarlos en RPubs; lanzado en 2010.",
					B: "Es un paquete para limpiar y transformar datos de manera eficiente; lanzado en 2015.",
					C: "Permite la creaci칩n de aplicaciones web interactivas y dashboards directamente desde R; su primera versi칩n beta p칰blica se lanz칩 en 2013.",
					D: "Es una extensi칩n de R Markdown para generar presentaciones; lanzado en 2018."
				},
				correctAnswer: "C",
				explanation: "Shiny revolucion칩 la capacidad de los usuarios de R para compartir resultados, permitiendo construir potentes aplicaciones web interactivas y dashboards sin necesidad de conocimientos avanzados de desarrollo web. Su lanzamiento beta en 2013 marc칩 un hito importante."
			},
			{
				question: "Describe brevemente la separaci칩n entre las capas UI (interfaz de usuario) y Server en una aplicaci칩n Shiny.",
				options: {
					A: "La capa UI contiene el c칩digo R, y la capa Server define el dise침o visual.",
					B: "La capa UI maneja la l칩gica de base de datos, y la capa Server maneja la visualizaci칩n.",
					C: "Ambas capas contienen el mismo tipo de c칩digo R, pero se ejecutan en paralelo.",
					D: "La capa UI define la apariencia y los elementos interactivos (inputs/outputs), mientras que la capa Server contiene la l칩gica de R que procesa datos y genera las salidas en respuesta a las interacciones."
				},
				correctAnswer: "D",
				explanation: "Esta separaci칩n es el coraz칩n de la arquitectura Shiny. UI se encarga de lo que el usuario ve e interact칰a (botones, sliders, placeholders para gr치ficos), mientras que Server es el 'cerebro' que realiza los c치lculos, filtra datos, genera gr치ficos y actualiza los elementos en la UI bas치ndose en la actividad del usuario."
			},
			{
				question: "쯈u칠 significa el concepto de 'reactividad' en el contexto de Shiny?",
				options: {
					A: "La capacidad de la aplicaci칩n para conectarse a diferentes bases de datos.",
					B: "La velocidad con la que el c칩digo R se ejecuta en el servidor.",
					C: "La habilidad de la aplicaci칩n para generar informes PDF de forma autom치tica.",
					D: "La capacidad de la aplicaci칩n para actualizar autom치ticamente partes de la interfaz de usuario (outputs) en respuesta a cambios en las entradas del usuario (inputs) o datos, sin recargar la p치gina completa."
				},
				correctAnswer: "D",
				explanation: "La reactividad es la caracter칤stica distintiva de Shiny que permite crear experiencias de usuario din치micas e interactivas. Los outputs 'reaccionan' a los cambios en los inputs del usuario, actualiz치ndose en tiempo real, lo que facilita la exploraci칩n de datos interactiva."
			}
		];

		let shuffledQuizData = []; // Array para almacenar las preguntas aleatorizadas
		let currentQuestionIndex = 0; // 칈ndice de la pregunta actual
		let score = 0; // Puntaje del usuario (solo correctas)
		let timerInterval; // Variable para almacenar el intervalo del temporizador
		const TOTAL_QUIZ_TIME = 60; // Tiempo total en segundos para todo el quiz
		let timeLeft = TOTAL_QUIZ_TIME; // Tiempo restante total del quiz
		let quizActive = true; // Bandera para saber si el quiz est치 activo

		// Obtener referencias a los elementos del DOM - 춰Ahora dentro de window.onload!
		let questionTextElement;
		let optionsAreaElement;
		let submitButton;
		let nextButton;
		let restartButton;
		let feedbackAreaElement;
		let scoreAttemptedButton; // Bot칩n para Intentadas
		let scoreCorrectButton;   // Bot칩n para Correctas
		let scoreIncorrectButton; // Bot칩n para Incorrectas
		let timerAreaElement;
		let quizContentElement;
		let endScreenElement;
		let scoreContainerElement; // Contenedor de los botones de puntaje
		let darkModeToggle; // Bot칩n de modo oscuro
		let sessionHistoryList; // Lista para el historial de sesiones
		let clearHistoryButton; // Bot칩n para borrar historial
		let progressChartContainer; // Contenedor del gr치fico de progreso
		let progressChartElement; // Elemento donde se dibuja el gr치fico
		let tooltip; // Referencia al tooltip de D3
		let tabButtons; // Botones de pesta침a
		let tabContents; // Contenido de las pesta침as


		// Funci칩n para mezclar un array (Algoritmo Fisher-Yates (Knuth) Shuffle)
		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]]; // Intercambiar elementos
			}
			return array;
		}

		// Funci칩n para mezclar las opciones de un objeto de opciones
		function shuffleOptions(optionsObject) {
			const optionKeys = Object.keys(optionsObject);
			shuffleArray(optionKeys); // Mezclar las claves (A, B, C, D)
			const shuffledOptions = {};
			optionKeys.forEach(key => {
				shuffledOptions[key] = optionsObject[key]; // Reconstruir el objeto con el orden mezclado
			});
			return shuffledOptions;
		}


		// Funci칩n para iniciar el temporizador global del quiz
		function startGlobalTimer() {
			timeLeft = TOTAL_QUIZ_TIME; // Reiniciar tiempo total
			timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`; // Mostrar tiempo inicial

			timerInterval = setInterval(() => {
				timeLeft--;
				timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`;

				if (timeLeft <= 0) {
					clearInterval(timerInterval); // Detener el temporizador
					endQuiz(true); // Finalizar el quiz porque el tiempo se agot칩
				}
			}, 1000); // Actualizar cada 1 segundo
		}

		// Funci칩n para detener el temporizador
		function stopTimer() {
			clearInterval(timerInterval);
		}

		// Funci칩n para cargar y mostrar la pregunta actual
		function loadQuestion() {
			if (!quizActive) return; // No cargar pregunta si el quiz no est치 activo

			// Limpiar 치rea de opciones y feedback
			optionsAreaElement.innerHTML = '';
			feedbackAreaElement.innerHTML = '';
			feedbackAreaElement.classList.add('hidden'); // Ocultar feedback
			feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning'); // Limpiar clases de feedback

			// Asegurarse de que el contenido del quiz est칠 visible y la pantalla final oculta
			quizContentElement.classList.remove('hidden');
			endScreenElement.classList.add('hidden');
			timerAreaElement.classList.remove('hidden'); // Asegurarse de que el temporizador sea visible
			scoreContainerElement.classList.remove('hidden'); // Asegurarse de que el contenedor de puntaje sea visible
			progressChartContainer.classList.add('hidden'); // Ocultar el gr치fico de progreso


			// Habilitar las opciones de respuesta al cargar una nueva pregunta
			enableOptions();

			// Deseleccionar cualquier radio button previamente seleccionado
			const selectedRadio = optionsAreaElement.querySelector('input[name="answer"]:checked');
			if (selectedRadio) {
				selectedRadio.checked = false;
			}


			// Obtener la pregunta actual del array de preguntas aleatorizadas
			const currentQuestion = shuffledQuizData[currentQuestionIndex];

			// Mostrar el texto de la pregunta
			questionTextElement.textContent = currentQuestion.question;

			// Mezclar las opciones de la pregunta actual
			const shuffledOptions = shuffleOptions(currentQuestion.options);

			// Crear y mostrar las opciones de respuesta mezcladas
			for (const optionKey in shuffledOptions) {
				if (shuffledOptions.hasOwnProperty(optionKey)) {
					const optionValue = shuffledOptions[optionKey];

					// Crear un div para cada opci칩n para mejor estructura y padding
					const optionDiv = document.createElement('div');

					const input = document.createElement('input');
					input.type = 'radio';
					input.name = 'answer'; // Mismo nombre para que solo una opci칩n sea seleccionable
					input.value = optionKey;
					input.id = `option-${optionKey}`; // ID 칰nico para la etiqueta

					const label = document.createElement('label');
					label.textContent = `${optionKey}) ${optionValue}`;
					label.htmlFor = `option-${optionKey}`; // Asociar etiqueta con input

					// A침adir input y label al div de la opci칩n
					optionDiv.appendChild(input);
					optionDiv.appendChild(label);

					// A침adir el div de la opci칩n al 치rea de opciones
					optionsAreaElement.appendChild(optionDiv);
				}
			}

			// Mostrar el bot칩n de responder y ocultar el de siguiente
			submitButton.classList.remove('hidden');
			nextButton.classList.add('hidden');

			// Habilitar el bot칩n de responder
			submitButton.disabled = false;

			// Actualizar el puntaje mostrado (Intentadas, Correctas, Incorrectas)
			updateScoreDisplay();

			// Deshabilitar opciones si el tiempo se agot칩 (aunque endQuiz deber칤a manejar esto)
			if (timeLeft <= 0) {
				disableOptions();
				submitButton.disabled = true;
			}
		}

		// Funci칩n para deshabilitar las opciones de respuesta
		function disableOptions() {
			const options = optionsAreaElement.querySelectorAll('input[name="answer"]');
			options.forEach(option => {
				option.disabled = true;
			});
		}

		// Funci칩n para habilitar las opciones de respuesta
		function enableOptions() {
			const options = optionsAreaElement.querySelectorAll('input[name="answer"]');
			options.forEach(option => {
				option.disabled = false;
			});
		}


		// Funci칩n para verificar la respuesta seleccionada
		function checkAnswer() {
			if (!quizActive) return; // No procesar respuesta si el quiz no est치 activo

			// Obtener la opci칩n seleccionada por el usuario
			const selectedOption = document.querySelector('input[name="answer"]:checked');

			// Si no se seleccion칩 ninguna opci칩n, mostrar un mensaje y no continuar
			if (!selectedOption) {
				feedbackAreaElement.classList.remove('hidden');
				feedbackAreaElement.classList.remove('correct', 'incorrect'); // Limpiar clases
				feedbackAreaElement.classList.add('warning'); // Usar la clase warning para este tipo de mensaje
				feedbackAreaElement.innerHTML = '<strong>Por favor, selecciona una opci칩n antes de responder.</strong>';
				return; // Salir de la funci칩n si no hay selecci칩n
			}

			// Deshabilitar el bot칩n de responder para evitar m칰ltiples env칤os
			submitButton.disabled = true;
			disableOptions(); // Deshabilitar opciones despu칠s de responder

			let userAnswer = selectedOption.value;


			// Obtener la respuesta correcta de la pregunta actual (del array mezclado)
			const correctAnswer = shuffledQuizData[currentQuestionIndex].correctAnswer;
			const explanation = shuffledQuizData[currentQuestionIndex].explanation;

			// Mostrar el 치rea de feedback
			feedbackAreaElement.classList.remove('hidden');

			// Limpiar clases de feedback previas
			feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning');

			// Comprobar si la respuesta es correcta
			if (userAnswer === correctAnswer) {
				score++; // Incrementar puntaje si es correcta
				feedbackAreaElement.classList.add('correct');
				feedbackAreaElement.innerHTML = '<strong>춰Correcto!</strong>';
			} else {
				feedbackAreaElement.classList.add('incorrect');
				feedbackAreaElement.innerHTML = `<strong>Incorrecto.</strong> La respuesta correcta es ${correctAnswer}.`;
			}

			// A침adir la explicaci칩n al feedback
			const explanationElement = document.createElement('p');
			explanationElement.classList.add('explanation');
			explanationElement.textContent = explanation;
			feedbackAreaElement.appendChild(explanationElement);

			// Ocultar el bot칩n de responder y mostrar el de siguiente
			submitButton.classList.add('hidden');
			// Solo mostrar el bot칩n siguiente si el tiempo no se ha agotado
			if (timeLeft > 0) {
				nextButton.classList.remove('hidden');
			} else {
				// Si el tiempo se agot칩, ir directamente a la pantalla final
				endQuiz(true);
			}


			// Actualizar la visualizaci칩n del puntaje (despu칠s de incrementar el score si fue correcta)
			updateScoreDisplay();
		}

		// Funci칩n para pasar a la siguiente pregunta o finalizar el quiz
		function nextQuestion() {
			if (!quizActive) return; // No pasar de pregunta si el quiz no est치 activo

			currentQuestionIndex++; // Incrementar el 칤ndice de la pregunta

			// Verificar si hay m치s preguntas (en el array mezclado) y si el tiempo no se ha agotado
			if (currentQuestionIndex < shuffledQuizData.length && timeLeft > 0) {
				loadQuestion(); // Cargar la siguiente pregunta
			} else {
				endQuiz(false); // Finalizar el quiz (ya sea por terminar preguntas o por tiempo agotado)
			}
		}

		// Funci칩n para actualizar la visualizaci칩n del puntaje
		function updateScoreDisplay() {
			// currentQuestionIndex es el n칰mero de preguntas que ya se han mostrado.
			// Si el bot칩n "Responder" est치 visible, significa que la pregunta actual a칰n no se ha respondido,
			// por lo que el n칰mero de intentadas es igual al 칤ndice actual.
			// Si el bot칩n "Siguiente Pregunta" est치 visible, significa que la pregunta actual ya se respondi칩,
			// por lo que el n칰mero de intentadas es el 칤ndice actual + 1.
			const attempted = currentQuestionIndex + (nextButton.classList.contains('hidden') ? 0 : 1);

			const correct = score;
			const incorrect = attempted - correct;

			// Actualizar el texto de los botones de puntaje
			scoreAttemptedButton.textContent = `Intentadas: ${attempted}`;
			scoreCorrectButton.textContent = `Correctas: ${correct}`;
			scoreIncorrectButton.textContent = `Incorrectas: ${incorrect}`;
		}

		// Funci칩n para finalizar el quiz
		function endQuiz(timeRanOut) {
			if (!quizActive) return; // Evitar finalizar m칰ltiples veces
			quizActive = false; // Marcar el quiz como inactivo

			// Detener el temporizador final
			stopTimer();
			timerAreaElement.classList.add('hidden'); // Ocultar el temporizador al finalizar

			// Ocultar el contenido del quiz
			quizContentElement.classList.add('hidden');
			scoreContainerElement.classList.add('hidden'); // Ocultar los botones de puntaje principales


			// Mostrar la pantalla final
			endScreenElement.classList.remove('hidden');

			// Mostrar mensaje de fin de quiz
			const endTitle = document.createElement('h2');
			endTitle.classList.add('text-xl', 'font-bold', 'text-center', 'text-gray-800', 'mb-4');
			if (timeRanOut) {
				endTitle.textContent = '춰Tiempo agotado!';
			} else {
				endTitle.textContent = '춰Quiz Finalizado!';
			}

			// Calcular el puntaje final detallado
			const totalAttempted = currentQuestionIndex; // Total de preguntas que se intentaron
			const finalCorrect = score;
			const finalIncorrect = totalAttempted - finalCorrect;


			// Determinar el mensaje basado en el puntaje
			let scoreMessageText = "";
			if (finalCorrect < 3) {
				scoreMessageText = "Sigue repasando el contenido, cada intento puedes mejorar.";
			} else if (finalCorrect >= 3 && finalCorrect < 5) {
				scoreMessageText = "춰Bien! Est치s avanzando por el camino de R, sigue repasando.";
			} else { // finalCorrect >= 5
				scoreMessageText = "춰Sigue as칤! Est치s aprendiendo a trabajar con R.";
			}

			const scoreMessageElement = document.createElement('p');
			scoreMessageElement.classList.add('end-message', 'text-center');
			scoreMessageElement.textContent = scoreMessageText;

			// Crear un nuevo contenedor para los botones de puntaje finales
			const finalScoreContainer = document.createElement('div');
			finalScoreContainer.classList.add('score-container'); // Reutilizar la clase de estilo


			// Crear y a침adir los botones de puntaje finales
			const finalAttemptedButton = document.createElement('span');
			finalAttemptedButton.classList.add('score-button', 'attempted');
			finalAttemptedButton.textContent = `Intentadas: ${totalAttempted}`;
			finalScoreContainer.appendChild(finalAttemptedButton);

			const finalCorrectButton = document.createElement('span');
			finalCorrectButton.classList.add('score-button', 'correct');
			finalCorrectButton.textContent = `Correctas: ${finalCorrect}`;
			finalScoreContainer.appendChild(finalCorrectButton);

			const finalIncorrectButton = document.createElement('span');
			finalIncorrectButton.classList.add('score-button', 'incorrect');
			finalIncorrectButton.textContent = `Incorrectas: ${finalIncorrect}`;
			finalScoreContainer.appendChild(finalIncorrectButton);


			// Limpiar el contenido anterior de la pantalla final y a침adir los nuevos elementos
			endScreenElement.innerHTML = '';
			endScreenElement.appendChild(endTitle);
			endScreenElement.appendChild(finalScoreContainer); // A침adir el contenedor de botones de puntaje finales
			endScreenElement.appendChild(scoreMessageElement); // A침adir el mensaje basado en el puntaje

			// --- Agregar la secci칩n de resumen de preguntas respondidas ---
			const summarySection = document.createElement('div');
			summarySection.classList.add('summary-section');

			const summaryTitle = document.createElement('h3');
			summaryTitle.textContent = 'Resumen de Preguntas Respondidas';
			summarySection.appendChild(summaryTitle);

			// Iterar solo sobre las preguntas que fueron presentadas en este quiz
			// currentQuestionIndex es el n칰mero de preguntas que se intentaron/vieron
			for (let i = 0; i < currentQuestionIndex; i++) {
				const questionData = shuffledQuizData[i]; // Obtener la pregunta del array mezclado

				const summaryItem = document.createElement('div');
				summaryItem.classList.add('summary-item');

				const questionText = document.createElement('p');
				questionText.innerHTML = `<strong>Pregunta ${i + 1}:</strong> ${questionData.question}`; // Usar i+1 para el n칰mero de pregunta en el resumen
				summaryItem.appendChild(questionText);

				const correctAnswer = document.createElement('p');
				// Encontrar el texto de la respuesta correcta usando la clave
				const correctAnswerText = questionData.options[questionData.correctAnswer];
				correctAnswer.innerHTML = `<span class="correct-answer">Respuesta Correcta: ${questionData.correctAnswer}) ${correctAnswerText}</span>`;
				summaryItem.appendChild(correctAnswer);

				const explanation = document.createElement('p');
				explanation.classList.add('explanation');
				explanation.textContent = `Explicaci칩n: ${questionData.explanation}`;
				summaryItem.appendChild(explanation);

				summarySection.appendChild(summaryItem);
			}


			endScreenElement.appendChild(summarySection); // A침adir la secci칩n de resumen a la pantalla final
			// --- Fin de la secci칩n de resumen ---


			// Mostrar el bot칩n de reiniciar
			restartButton.classList.remove('hidden');
			endScreenElement.appendChild(restartButton); // A침adir el bot칩n de reiniciar a la pantalla final

			// Asegurarse de que el 치rea de puntaje principal est칠 oculta al mostrar el puntaje final en la pantalla final
			// scoreAreaElement.classList.add('hidden'); // Esto ya no es necesario ya que ocultamos scoreContainerElement

			// Guardar el resultado de la sesi칩n en localStorage
			saveSessionResult({
				attempted: totalAttempted,
				correct: finalCorrect,
				incorrect: finalIncorrect,
				timestamp: new Date().toISOString() // Opcional: guardar la hora del intento
			});

			// Enviar datos al backend (solo esqueleto)
			sendResultToBackend({
				attempted: totalAttempted,
				correct: finalCorrect,
				incorrect: finalIncorrect,
				timestamp: new Date().toISOString(),
				quizId: 'r_markdown_shiny_quiz' // Identificador del quiz
			});

			// Mostrar el gr치fico de progreso al finalizar el quiz
			// progressChartContainer.classList.remove('hidden'); // Ya no se muestra aqu칤, se muestra en la pesta침a Progreso
			// drawProgressChart(); // Ya no se dibuja aqu칤
		}

		// Funci칩n para guardar el resultado de la sesi칩n en localStorage
		function saveSessionResult(result) {
			const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
			results.push(result);
			localStorage.setItem('quizResults', JSON.stringify(results));
			displaySessionHistory(); // Actualizar la visualizaci칩n del historial
		}

		// Funci칩n para cargar y mostrar el historial de sesiones
		function displaySessionHistory() {
			const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
			sessionHistoryList.innerHTML = ''; // Limpiar la lista actual

			if (results.length === 0) {
				sessionHistoryList.innerHTML = '<p class="text-center text-gray-500">A칰n no hay intentos en esta sesi칩n.</p>';
				// Ocultar el gr치fico si no hay historial
				progressChartContainer.classList.add('hidden');
				return;
			}

			results.forEach((result, index) => {
				const sessionItem = document.createElement('div');
				sessionItem.classList.add('session-item');
				sessionItem.innerHTML = `
                     <p><strong>Intento ${index + 1}:</strong></p>
                     <p class="score-detail">Intentadas: ${result.attempted}, Correctas: ${result.correct}, Incorrectas: ${result.incorrect}</p>
                     ${result.timestamp ? `<p class="score-detail">Hora: ${new Date(result.timestamp).toLocaleString()}</p>` : ''}
                 `;
				sessionHistoryList.appendChild(sessionItem);
			});

			// Mostrar el gr치fico si hay historial
			progressChartContainer.classList.remove('hidden');
			drawProgressChart(); // Dibujar el gr치fico con los datos del historial
		}

		// Funci칩n para borrar el historial de sesiones
		function clearSessionHistory() {
			localStorage.removeItem('quizResults');
			displaySessionHistory(); // Actualizar la visualizaci칩n (mostrar치 el mensaje de "A칰n no hay intentos")
		}


		// Funci칩n placeholder para enviar datos al backend
		function sendResultToBackend(resultData) {
			// ** ESTO ES SOLO UN ESQUELETO **
			// Para que esto funcione, necesitas un servidor backend configurado
			// para recibir peticiones POST en la URL especificada.
			const backendUrl = 'TU_URL_DEL_BACKEND_PARA_GUARDAR_RESULTADOS'; // <<< Reemplaza con tu URL real

			console.log('Intentando enviar datos al backend:', resultData); // Log para depuraci칩n

			// Descomenta el siguiente bloque para intentar enviar datos (requiere backend)
			/*
			fetch(backendUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(resultData),
			})
			.then(response => {
				if (!response.ok) {
					console.error('Error al enviar datos al backend:', response.statusText);
				}
				return response.json();
			})
			.then(data => {
				console.log('Respuesta del backend:', data);
			})
			.catch((error) => {
				console.error('Error en la conexi칩n con el backend:', error);
			});
			*/
		}

		// Funci칩n para dibujar el gr치fico de progreso usando D3.js
		function drawProgressChart() {
			const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
			progressChartElement.innerHTML = ''; // Limpiar el 치rea del gr치fico anterior

			if (results.length === 0) {
				// No dibujar gr치fico si no hay datos
				return;
			}

			const data = results.map((r, i) => ({
				attempt: i + 1,
				correct: r.correct,
				incorrect: r.incorrect
			}));

			const margin = { top: 20, right: 20, bottom: 30, left: 40 };
			const width = 600 - margin.left - margin.right;
			const height = 300 - margin.top - margin.bottom;

			// Seleccionar el contenedor y a침adir el SVG
			const svg = d3.select("#progress-chart").append("svg")
				.attr("width", "100%") // Usar ancho relativo
				.attr("height", height + margin.top + margin.bottom)
				.attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // A침adir viewBox para responsividad
				.attr("preserveAspectRatio", "xMidYMid meet") // Mantener aspecto
				.append("g")
				.attr("transform", `translate(${margin.left},${margin.top})`);

			// Escalas
			const xScale = d3.scaleBand()
				.range([0, width])
				.padding(0.1)
				.domain(data.map(d => d.attempt)); // Dominio aqu칤

			const yScale = d3.scaleLinear()
				.range([height, 0])
				.domain([0, d3.max(data, d => d.correct + d.incorrect)]); // El eje Y va hasta el total de intentadas

			// A침adir ejes
			svg.append("g")
				.attr("class", "axis axis--x")
				.attr("transform", `translate(0,${height})`)
				.call(d3.axisBottom(xScale));

			svg.append("g")
				.attr("class", "axis axis--y")
				.call(d3.axisLeft(yScale));

			// Crear grupos para las barras (correctas e incorrectas apiladas)
			const attempts = svg.selectAll(".attempt")
				.data(data)
				.enter().append("g")
				.attr("class", "attempt")
				.attr("transform", d => `translate(${xScale(d.attempt)},0)`);

			// Barras incorrectas (base)
			attempts.append("rect")
				.attr("class", "incorrect-bar")
				.attr("y", d => yScale(d.incorrect))
				.attr("height", d => height - yScale(d.incorrect))
				.attr("width", xScale.bandwidth());

			// Barras correctas (encima de las incorrectas)
			attempts.append("rect")
				.attr("class", "correct-bar")
				.attr("y", d => yScale(d.incorrect + d.correct)) // La parte superior de la barra correcta es la suma
				.attr("height", d => height - yScale(d.correct)) // La altura es solo las correctas
				.attr("width", xScale.bandwidth());

			// --- Eliminar funcionalidad de Tooltip ---
			// Se elimina la creaci칩n del elemento tooltip en window.onload y los event listeners mouseover/mouseout aqu칤.
			// Si se desea una alternativa, se puede descomentar el c칩digo de etiquetas est치ticas.

			// Opcional: A침adir etiquetas de texto est치tico sobre las barras
			// Esto puede saturar el gr치fico si hay muchos intentos, pero es una alternativa a los tooltips.
			// Si quieres implementarlo, descomenta y ajusta el siguiente c칩digo:
			/*
			attempts.append("text")
				.attr("class", "bar-label")
				.attr("x", xScale.bandwidth() / 2) // Centrar el texto en la barra
				.attr("y", d => yScale(d.incorrect + d.correct) - 5) // Posicionar encima de la barra correcta
				.attr("dy", ".35em") // Ajuste vertical
				.text(d => d.correct) // Mostrar solo el n칰mero de correctas
				.style("fill", "white") // Color del texto
				.style("text-anchor", "middle") // Alinear texto al centro
				.style("font-size", "0.7em"); // Tama침o de fuente

			attempts.append("text")
				.attr("class", "bar-label")
				.attr("x", xScale.bandwidth() / 2) // Centrar el texto en la barra
				.attr("y", d => yScale(d.incorrect) - 5) // Posicionar encima de la barra incorrecta
				 .attr("dy", ".35em") // Ajuste vertical
				.text(d => d.incorrect) // Mostrar solo el n칰mero de incorrectas
				.style("fill", "white") // Color del texto
				.style("text-anchor", "middle") // Alinear texto al centro
				.style("font-size", "0.7em"); // Tama침o de fuente
			*/

			// Ajustar el tama침o del SVG para que sea responsivo (b치sico)
			// No es necesario redibujar todo en redimensionamiento si se usa viewBox y preserveAspectRatio
			// d3.select(window).on('resize', () => {
			//     drawProgressChart();
			// });
		}


		// Funci칩n para cambiar de pesta침a
		function changeTab(tabId) {
			// Ocultar todo el contenido de las pesta침as
			tabContents.forEach(content => {
				content.classList.remove('active');
			});

			// Desactivar todos los botones de pesta침a
			tabButtons.forEach(button => {
				button.classList.remove('active');
			});

			// Mostrar el contenido de la pesta침a seleccionada
			document.getElementById(tabId).classList.add('active');

			// Activar el bot칩n de la pesta침a seleccionada
			document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');

			// Si la pesta침a de progreso est치 activa, dibujar el gr치fico
			if (tabId === 'progress-tab') {
				drawProgressChart();
			}
		}


		// Funci칩n para reiniciar el quiz
		function restartQuiz() {
			currentQuestionIndex = 0; // Reiniciar 칤ndice de pregunta
			score = 0; // Reiniciar puntaje
			quizActive = true; // Marcar el quiz como activo

			// Mezclar las preguntas nuevamente al reiniciar
			shuffledQuizData = shuffleArray([...originalQuizData]); // Usar una copia del array original

			// Reiniciar la visualizaci칩n del puntaje antes de cargar la primera pregunta
			scoreAttemptedButton.textContent = `Intentadas: 0`;
			scoreCorrectButton.textContent = `Correctas: 0`;
			scoreIncorrectButton.textContent = `Incorrectas: 0`;


			loadQuestion(); // Cargar la primera pregunta
			startGlobalTimer(); // Iniciar el temporizador global

			// Ocultar la pantalla final al iniciar un nuevo quiz
			endScreenElement.classList.add('hidden');
			// Asegurarse de que el contenido del quiz est칠 visible
			quizContentElement.classList.remove('hidden');
			// Asegurarse de que el contenedor de puntaje principal sea visible
			scoreContainerElement.classList.remove('hidden');
			progressChartContainer.classList.add('hidden'); // Ocultar el gr치fico al reiniciar

			// Cambiar a la pesta침a del quiz al reiniciar
			changeTab('quiz-tab');
		}

		// Funci칩n para alternar el modo oscuro
		function toggleDarkMode() {
			document.body.classList.toggle('dark-mode');
			// Opcional: guardar la preferencia en localStorage para que persista
			if (document.body.classList.contains('dark-mode')) {
				localStorage.setItem('darkMode', 'enabled');
			} else {
				localStorage.setItem('darkMode', 'disabled');
			}
			// Redibujar el gr치fico para aplicar estilos de modo oscuro si est치 visible
			if (!progressChartContainer.classList.contains('hidden')) {
				drawProgressChart();
			}
		}


		// Este c칩digo se ejecutar치 una vez que toda la p치gina HTML est칠 completamente cargada
		window.onload = () => {
			// Obtener referencias a los elementos del DOM
			questionTextElement = document.getElementById('question-text');
			optionsAreaElement = document.getElementById('options-area');
			submitButton = document.getElementById('submit-answer');
			nextButton = document.getElementById('next-question');
			restartButton = document.getElementById('restart-quiz'); // Obtener referencia al bot칩n de reiniciar
			feedbackAreaElement = document.getElementById('feedback-area');
			scoreContainerElement = document.getElementById('score-area'); // Referencia al contenedor
			timerAreaElement = document.getElementById('timer-area');
			quizContentElement = document.getElementById('quiz-content');
			endScreenElement = document.getElementById('end-screen');
			darkModeToggle = document.getElementById('dark-mode-toggle'); // Referencia al bot칩n de modo oscuro
			sessionHistoryList = document.getElementById('session-history-list'); // Referencia a la lista del historial
			clearHistoryButton = document.getElementById('clear-history-button'); // Referencia al bot칩n de borrar historial
			progressChartContainer = document.querySelector('.progress-chart-container'); // Referencia al contenedor del gr치fico
			progressChartElement = document.getElementById('progress-chart'); // Referencia al elemento donde dibujar el gr치fico
			tabButtons = document.querySelectorAll('.tab-button'); // Referencia a los botones de pesta침a
			tabContents = document.querySelectorAll('.tab-content'); // Referencia al contenido de las pesta침as


			// Crear los elementos para los botones de puntaje
			scoreAttemptedButton = document.createElement('span');
			scoreAttemptedButton.classList.add('score-button', 'attempted');
			scoreContainerElement.appendChild(scoreAttemptedButton);

			scoreCorrectButton = document.createElement('span');
			scoreCorrectButton.classList.add('score-button', 'correct');
			scoreContainerElement.appendChild(scoreCorrectButton);

			scoreIncorrectButton = document.createElement('span');
			scoreIncorrectButton.classList.add('score-button', 'incorrect');
			scoreContainerElement.appendChild(scoreIncorrectButton);

			// --- Eliminar creaci칩n de Tooltip aqu칤 ---
			// El elemento tooltip y su l칩gica de mouseover/mouseout se eliminan de drawProgressChart.


			// Event listeners para los botones de acci칩n
			submitButton.addEventListener('click', checkAnswer);
			nextButton.addEventListener('click', nextQuestion);
			restartButton.addEventListener('click', restartQuiz); // Event listener para el bot칩n de reiniciar
			darkModeToggle.addEventListener('click', toggleDarkMode); // Event listener para el bot칩n de modo oscuro
			clearHistoryButton.addEventListener('click', clearSessionHistory); // Event listener para borrar historial

			// Event listeners para los botones de pesta침a
			tabButtons.forEach(button => {
				button.addEventListener('click', () => {
					const tabId = button.getAttribute('data-tab');
					changeTab(tabId);
				});
			});


			// Cargar la preferencia de modo oscuro guardada (si existe)
			if (localStorage.getItem('darkMode') === 'enabled') {
				document.body.classList.add('dark-mode');
			}

			// Cargar y mostrar el historial de sesiones al cargar la p치gina
			displaySessionHistory();

			// Inicializar la interfaz mostrando la primera pesta침a
			changeTab('quiz-tab');


			// Mezclar las preguntas al cargar la p치gina por primera vez
			shuffledQuizData = shuffleArray([...originalQuizData]); // Usar una copia del array original

			// Iniciar el temporizador global y cargar la primera pregunta al iniciar la p치gina
			startGlobalTimer(); // Iniciar el temporizador global
			loadQuestion(); // Cargar la primera pregunta
		};

	</script>

</body>

</html>