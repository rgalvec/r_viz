<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quiz: R, R Markdown, Quarto y Shiny</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<style>
		/* Estilos personalizados para la paleta de colores y alineación */
		body {
			font-family: "Inter", sans-serif;
			/* Usar fuente Inter */
			background-color: #f4f7f6;
			/* Color de fondo suave */
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 100vh;
			padding: 20px;
		}

		.quiz-container {
			background-color: #ffffff;
			/* Fondo blanco */
			padding: 30px;
			border-radius: 15px;
			/* Bordes redondeados */
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			/* Sombra suave */
			max-width: 700px;
			/* Ancho máximo */
			width: 100%;
		}

		.question {
			margin-bottom: 20px;
			font-size: 1.1em;
			font-weight: bold;
			color: #333;
			/* Color de texto oscuro para la pregunta */
		}

		.options label {
			display: flex;
			/* Usar flexbox para alinear input y texto */
			align-items: center;
			/* Centrar verticalmente */
			margin-bottom: 10px;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color 0.3s ease, border-color 0.3s ease;
			/* Transición suave */
			position: relative;
			/* Necesario para posicionar el pseudo-elemento */
			padding-left: 35px;
			/* Espacio a la izquierda para el cuadrado personalizado */
		}

		.options label:hover {
			background-color: #ffeacc;
			/* Naranja claro para hover */
			border-color: #ff9800;
			/* Naranja para el borde en hover */
		}

		/* Ocultar el radio button nativo */
		.options input[type="radio"] {
			position: absolute;
			/* Posicionamiento absoluto para sacarlo del flujo */
			opacity: 0;
			/* Hacerlo completamente transparente */
			cursor: pointer;
			/* Mantener el cursor de puntero */
			height: 0;
			/* Altura cero */
			width: 0;
			/* Ancho cero */
		}

		/* Crear el cuadrado personalizado */
		.options label::before {
			content: '';
			/* Contenido vacío es necesario para pseudo-elementos */
			position: absolute;
			/* Posicionamiento absoluto con respecto al label */
			left: 10px;
			/* Distancia desde el borde izquierdo del label */
			top: 50%;
			/* Centrar verticalmente */
			transform: translateY(-50%);
			/* Ajuste final para centrado perfecto */
			width: 20px;
			/* Tamaño del cuadrado */
			height: 20px;
			/* Tamaño del cuadrado */
			border: 2px solid #007bff;
			/* Borde azul */
			border-radius: 4px;
			/* Bordes ligeramente redondeados para el cuadrado */
			background-color: #fff;
			/* Fondo blanco */
			transition: all 0.3s ease;
			/* Transición suave para cambios */
		}

		/* Estilo para el cuadrado cuando el radio button está seleccionado */
		.options input[type="radio"]:checked+label::before {
			background-color: #007bff;
			/* Fondo azul cuando está seleccionado */
			border-color: #007bff;
			/* Borde azul cuando está seleccionado */
		}

		/* Estilo para el punto interior del cuadrado (opcional, si se desea un punto) */
		.options label::after {
			content: '';
			position: absolute;
			left: 16px;
			/* Ajustar la posición para que quede centrado en el cuadrado */
			top: 50%;
			transform: translateY(-50%);
			width: 8px;
			/* Tamaño del punto */
			height: 8px;
			/* Tamaño del punto */
			border-radius: 50%;
			/* Forma redonda */
			background-color: #fff;
			/* Color blanco para el punto */
			opacity: 0;
			/* Ocultar por defecto */
			transition: opacity 0.3s ease;
		}

		/* Mostrar el punto interior cuando el radio button está seleccionado */
		.options input[type="radio"]:checked+label::after {
			opacity: 1;
			/* Mostrar el punto */
		}


		.feedback {
			margin-top: 20px;
			padding: 15px;
			border-radius: 8px;
		}

		.feedback.correct {
			background-color: #d4edda;
			/* Verde claro (mantener para correcto por convención) */
			color: #155724;
			/* Verde oscuro */
			border-color: #c3e6cb;
		}

		.feedback.incorrect {
			background-color: #f8d7da;
			/* Rojo claro (mantener para incorrecto por convención) */
			color: #721c24;
			/* Rojo oscuro */
			border-color: #f5c6cb;
		}

		/* Estilo para el feedback de "selecciona una opción" */
		.feedback.warning {
			background-color: #fff3cd;
			/* Amarillo claro */
			color: #856404;
			/* Amarillo oscuro */
			border-color: #ffeeba;
		}

		.explanation {
			margin-top: 10px;
			font-size: 0.95em;
			color: #555;
			/* Color de texto para la explicación */
		}

		.score {
			margin-top: 20px;
			font-size: 1.2em;
			font-weight: bold;
			text-align: center;
			color: #007bff;
			/* Azul para el puntaje */
		}

		.button {
			/* Estilo base del botón con Tailwind */
			@apply text-white font-bold py-2 px-4 rounded-lg mt-4 transition duration-300 ease-in-out;
			width: auto;
			/* Ancho automático para que sea más pequeño */
			display: block;
			/* Para que margin: auto funcione */
			margin-left: auto;
			/* Centrar el botón */
			margin-right: auto;
			/* Centrar el botón */
			background-color: #007bff;
			/* Fondo azul */
			color: #ffffff;
			/* Letras blancas */
			border: none;
			/* Sin borde */
			cursor: pointer;
		}

		.button:disabled {
			@apply bg-gray-400 hover:bg-gray-400 cursor-not-allowed;
		}

		.button:hover:not(:disabled) {
			background-color: #0056b3;
			/* Azul más oscuro en hover */
		}

		/* Estilo para el mensaje final del quiz */
		.quiz-container h2 {
			color: #007bff;
			/* Azul para el título final */
		}

		.quiz-container .score {
			color: #ff9800;
			/* Naranja para el puntaje final */
		}
	</style>
</head>

<body>

	<div class="quiz-container">
		<h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Quiz: R, R Markdown, Quarto y Shiny</h1>

		<div id="question-area">
			<div class="question" id="question-text"></div>
			<div class="options" id="options-area">
			</div>
		</div>

		<button id="submit-answer" class="button">Responder</button>
		<button id="next-question" class="button hidden">Siguiente Pregunta</button>

		<div id="feedback-area" class="feedback hidden">
		</div>

		<div class="score" id="score-area">
			Puntaje: 0 / 0
		</div>
	</div>

	<script>
		// Array de objetos para almacenar las preguntas, opciones, respuestas correctas y explicaciones.
		// Basado en el contenido proporcionado por el usuario.
		const quizData = [
			{
				question: "¿Cuál es la función principal del menú 'Publish' en el contexto de R Markdown o Quarto?",
				options: {
					A: "Ejecutar todos los chunks de código del documento.",
					B: "Formatear automáticamente el código fuente del documento.",
					C: "Compartir el documento renderizado en servicios online como RPubs.",
					D: "Guardar el documento en un formato específico como PDF o Word."
				},
				correctAnswer: "C",
				explanation: "La función del menú Publish es precisamente permitir a los usuarios compartir sus documentos renderizados en servicios en línea como RPubs, lo que simplifica la difusión de análisis y resultados a una audiencia más amplia."
			},
			{
				question: "¿Qué indica el botón 'Outline' en el editor de R Markdown o Quarto y cómo se activa?",
				options: {
					A: "Indica los errores de sintaxis en el código R; se activa al guardar el archivo.",
					B: "Muestra una vista previa del documento final renderizado; se activa con CTRL+Enter.",
					C: "Indica la estructura de carpetas del proyecto; se activa en el menú 'File'.",
					D: "Muestra un esquema navegable del documento basado en encabezados Markdown; se activa haciendo clic en su botón en la interfaz."
				},
				correctAnswer: "D",
				explanation: "El botón Outline muestra un esquema navegable del documento, construido a partir de los encabezados formateados con Markdown. Se activa simplemente haciendo clic en el botón correspondiente en la interfaz del editor, facilitando la navegación y comprensión de la estructura."
			},
			{
				question: "Describe la función de los botones 'Source' y 'Visual' en el editor de R Markdown o Quarto.",
				options: {
					A: "'Source' es para ver el código R y 'Visual' es para ver los gráficos generados.",
					B: "'Source' es para editar archivos de datos y 'Visual' es para editar el texto.",
					C: "Permiten alternar entre la vista del código fuente Markdown y una vista WYSIWYG (Lo que ves es lo que obtienes) más amigable para la edición.",
					D: "'Source' compila el documento y 'Visual' lo abre en el navegador."
				},
				correctAnswer: "C",
				explanation: "Los botones Source y Visual son fundamentales para la edición, permitiendo alternar fácilmente entre la manipulación directa del código fuente Markdown y una vista más visual y amigable (WYSIWYG), adaptándose a diferentes preferencias de edición."
			},
			{
				question: "¿Cómo se genera un documento final (renderizado) en R Markdown o Quarto, y qué opciones de formato de salida son comunes?",
				options: {
					A: "Se utiliza el comando render() en la consola de R; solo se puede generar HTML por defecto.",
					B: "Se guarda el archivo y se utiliza el botón 'Knit' o 'Render'; solo se pueden generar PDF y Word.",
					C: "Se ejecuta el código R del documento; el formato de salida es siempre texto plano.",
					D: "Se guarda el archivo y se utiliza el icono de 'renderizado', pudiendo elegir formatos como HTML, PDF o Word (especificados en YAML), con PDF requiriendo LaTeX."
				},
				correctAnswer: "D",
				explanation: "Para generar el documento final, se guarda el archivo y se usa el icono de renderizado. El triángulo junto a él permite elegir formatos de salida como HTML, PDF o Word, siempre que estén definidos en el encabezado YAML. Es importante recordar que PDF requiere la instalación de LaTeX."
			},
			{
				question: "¿Qué es un 'chunk' en R Markdown o Quarto y cuál es su propósito principal?",
				options: {
					A: "Es una sección de texto narrativo con formato especial.",
					B: "Es un bloque de configuración inicial del documento (YAML).",
					C: "Es un bloque de código R incrustado, delimitado por marcadores, cuyo propósito es ejecutar código y mostrar sus resultados en el documento.",
					D: "Es un enlace a un recurso externo o una imagen."
				},
				correctAnswer: "C",
				explanation: "Un chunk es la parte central de la reproducibilidad: un bloque de código R (u otro lenguaje en Quarto) delimitado por ```{r} y ``` que se ejecuta durante el renderizado para incluir los resultados (código, texto, tablas, gráficos) directamente en el documento final."
			},
			{
				question: "Menciona dos formas comunes de insertar un nuevo chunk de código en el editor de R Markdown o Quarto.",
				options: {
					A: "Copiar y pegar un chunk existente; usar el menú 'Edit'.",
					B: "Escribir manualmente los delimitadores ``` y {r}; usar la consola de R.",
					C: "Usar el atajo de teclado CTRL+ALT+I; hacer clic en el icono 'Insert a new code chunk' en la barra de herramientas.",
					D: "Usar el menú 'Tools'; arrastrar y soltar un script R."
				},
				correctAnswer: "C",
				explanation: "Las dos formas más directas y eficientes de insertar un chunk son mediante el atajo de teclado universal CTRL+ALT+I o haciendo clic en el icono dedicado ('Insert a new code chunk') en la barra de herramientas del editor."
			},
			{
				question: "¿Qué diferencia existe entre las opciones de chunk echo: false e include: false?",
				options: {
					A: "echo: false oculta los resultados del código, mientras que include: false oculta solo el código fuente.",
					B: "echo: false se usa para texto, include: false se usa para código.",
					C: "echo: false ejecuta el código pero oculta el código fuente en el documento final; include: false ejecuta el código pero oculta tanto el código fuente como sus resultados.",
					D: "echo: false detiene la ejecución del chunk, mientras que include: false la permite."
				},
				correctAnswer: "C",
				explanation: "La distinción es crucial para controlar qué se muestra en el documento. echo: false es útil cuando quieres mostrar solo el resultado de un cálculo o gráfico sin el código que lo generó. include: false oculta todo del chunk, útil para código que genera objetos que se usan más adelante pero no necesitas mostrar."
			},
			{
				question: "¿Cuál es la función principal del paquete Shiny y cuándo se lanzó aproximadamente su primera versión beta pública?",
				options: {
					A: "Es un paquete para crear informes estáticos y publicarlos en RPubs; lanzado en 2010.",
					B: "Es un paquete para limpiar y transformar datos de manera eficiente; lanzado en 2015.",
					C: "Permite la creación de aplicaciones web interactivas y dashboards directamente desde R; su primera versión beta pública se lanzó en 2013.",
					D: "Es una extensión de R Markdown para generar presentaciones; lanzado en 2018."
				},
				correctAnswer: "C",
				explanation: "Shiny revolucionó la capacidad de los usuarios de R para compartir resultados, permitiendo construir potentes aplicaciones web interactivas y dashboards sin necesidad de conocimientos avanzados de desarrollo web. Su lanzamiento beta en 2013 marcó un hito importante."
			},
			{
				question: "Describe brevemente la separación fundamental entre las capas UI (interfaz de usuario) y Server en una aplicación Shiny.",
				options: {
					A: "La capa UI contiene el código R, y la capa Server define el diseño visual.",
					B: "La capa UI maneja la lógica de base de datos, y la capa Server maneja la visualización.",
					C: "Ambas capas contienen el mismo tipo de código R, pero se ejecutan en paralelo.",
					D: "La capa UI define la apariencia y los elementos interactivos (inputs/outputs), mientras que la capa Server contiene la lógica de R que procesa datos y genera las salidas en respuesta a las interacciones."
				},
				correctAnswer: "D",
				explanation: "Esta separación es el corazón de la arquitectura Shiny. UI se encarga de lo que el usuario ve e interactúa (botones, sliders, placeholders para gráficos), mientras que Server es el 'cerebro' que realiza los cálculos, filtra datos, genera gráficos y actualiza los elementos en la UI basándose en la actividad del usuario."
			},
			{
				question: "¿Qué significa el concepto de 'reactividad' en el contexto de Shiny?",
				options: {
					A: "La capacidad de la aplicación para conectarse a diferentes bases de datos.",
					B: "La velocidad con la que el código R se ejecuta en el servidor.",
					C: "La habilidad de la aplicación para generar informes PDF de forma automática.",
					D: "La capacidad de la aplicación para actualizar automáticamente partes de la interfaz de usuario (outputs) en respuesta a cambios en las entradas del usuario (inputs) o datos, sin recargar la página completa."
				},
				correctAnswer: "D",
				explanation: "La reactividad es la característica distintiva de Shiny que permite crear experiencias de usuario dinámicas e interactivas. Los outputs 'reaccionan' a los cambios en los inputs del usuario, actualizándose en tiempo real, lo que facilita la exploración de datos interactiva."
			}
		];

		let currentQuestionIndex = 0; // Índice de la pregunta actual
		let score = 0; // Puntaje del usuario

		// Obtener referencias a los elementos del DOM
		const questionTextElement = document.getElementById('question-text');
		const optionsAreaElement = document.getElementById('options-area');
		const submitButton = document.getElementById('submit-answer');
		const nextButton = document.getElementById('next-question');
		const feedbackAreaElement = document.getElementById('feedback-area');
		const scoreAreaElement = document.getElementById('score-area');

		// Función para cargar y mostrar la pregunta actual
		function loadQuestion() {
			// Limpiar área de opciones y feedback
			optionsAreaElement.innerHTML = '';
			feedbackAreaElement.innerHTML = '';
			feedbackAreaElement.classList.add('hidden'); // Ocultar feedback
			feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning'); // Limpiar clases de feedback

			// Obtener la pregunta actual del array quizData
			const currentQuestion = quizData[currentQuestionIndex];

			// Mostrar el texto de la pregunta
			questionTextElement.textContent = currentQuestion.question;

			// Crear y mostrar las opciones de respuesta
			for (const optionKey in currentQuestion.options) {
				if (currentQuestion.options.hasOwnProperty(optionKey)) {
					const optionValue = currentQuestion.options[optionKey];

					// Crear un div para cada opción para mejor estructura y padding
					const optionDiv = document.createElement('div');

					const input = document.createElement('input');
					input.type = 'radio';
					input.name = 'answer'; // Mismo nombre para que solo una opción sea seleccionable
					input.value = optionKey;
					input.id = `option-${optionKey}`; // ID único para la etiqueta

					const label = document.createElement('label');
					label.textContent = `${optionKey}) ${optionValue}`;
					label.htmlFor = `option-${optionKey}`; // Asociar etiqueta con input

					// Añadir input y label al div de la opción
					optionDiv.appendChild(input);
					optionDiv.appendChild(label);

					// Añadir el div de la opción al área de opciones
					optionsAreaElement.appendChild(optionDiv);
				}
			}

			// Mostrar el botón de responder y ocultar el de siguiente
			submitButton.classList.remove('hidden');
			nextButton.classList.add('hidden');

			// Habilitar el botón de responder
			submitButton.disabled = false;

			// Actualizar el puntaje mostrado
			updateScoreDisplay();
		}

		// Función para verificar la respuesta seleccionada
		function checkAnswer() {
			// Obtener la opción seleccionada por el usuario
			const selectedOption = document.querySelector('input[name="answer"]:checked');

			// Deshabilitar el botón de responder para evitar múltiples envíos
			submitButton.disabled = true;

			// Verificar si se seleccionó alguna opción
			if (selectedOption) {
				const userAnswer = selectedOption.value;
				const correctAnswer = quizData[currentQuestionIndex].correctAnswer;
				const explanation = quizData[currentQuestionIndex].explanation;

				// Mostrar el área de feedback
				feedbackAreaElement.classList.remove('hidden');

				// Limpiar clases de feedback previas
				feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning');

				// Comprobar si la respuesta es correcta
				if (userAnswer === correctAnswer) {
					score++; // Incrementar puntaje si es correcta
					feedbackAreaElement.classList.add('correct');
					feedbackAreaElement.innerHTML = '<strong>¡Correcto!</strong>';
				} else {
					feedbackAreaElement.classList.add('incorrect');
					feedbackAreaElement.innerHTML = `<strong>Incorrecto.</strong> La respuesta correcta es ${correctAnswer}.`;
				}

				// Añadir la explicación al feedback
				const explanationElement = document.createElement('p');
				explanationElement.classList.add('explanation');
				explanationElement.textContent = explanation;
				feedbackAreaElement.appendChild(explanationElement);

				// Ocultar el botón de responder y mostrar el de siguiente
				submitButton.classList.add('hidden');
				nextButton.classList.remove('hidden');

				// Actualizar el puntaje mostrado
				updateScoreDisplay();

			} else {
				// Si no se seleccionó ninguna opción, mostrar un mensaje (opcional)
				feedbackAreaElement.classList.remove('hidden');
				feedbackAreaElement.classList.add('warning'); // Usar la clase warning para este tipo de mensaje
				feedbackAreaElement.innerHTML = '<strong>Por favor, selecciona una opción antes de responder.</strong>';
				submitButton.disabled = false; // Volver a habilitar el botón si no seleccionó nada
			}
		}

		// Función para pasar a la siguiente pregunta o finalizar el quiz
		function nextQuestion() {
			currentQuestionIndex++; // Incrementar el índice de la pregunta

			// Verificar si hay más preguntas
			if (currentQuestionIndex < quizData.length) {
				loadQuestion(); // Cargar la siguiente pregunta
			} else {
				endQuiz(); // Finalizar el quiz si no hay más preguntas
			}
		}

		// Función para actualizar la visualización del puntaje
		function updateScoreDisplay() {
			scoreAreaElement.textContent = `Puntaje: ${score} / ${quizData.length}`;
		}

		// Función para finalizar el quiz
		function endQuiz() {
			// Ocultar áreas de pregunta y botones
			document.getElementById('question-area').classList.add('hidden');
			submitButton.classList.add('hidden');
			nextButton.classList.add('hidden');
			feedbackAreaElement.classList.add('hidden'); // Ocultar feedback final

			// Mostrar mensaje de fin de quiz y puntaje final
			const endMessage = document.createElement('h2');
			endMessage.classList.add('text-xl', 'font-bold', 'text-center', 'text-gray-800');
			endMessage.textContent = '¡Quiz Finalizado!';

			const finalScoreMessage = document.createElement('p');
			finalScoreMessage.classList.add('score', 'text-center', 'mt-4'); // Usar clases de puntaje y centrar
			finalScoreMessage.textContent = `Tu puntaje final es: ${score} de ${quizData.length}`;

			const quizContainer = document.querySelector('.quiz-container');
			quizContainer.innerHTML = ''; // Limpiar contenido anterior
			quizContainer.appendChild(endMessage);
			quizContainer.appendChild(finalScoreMessage);
		}

		// Event listeners para los botones
		submitButton.addEventListener('click', checkAnswer);
		nextButton.addEventListener('click', nextQuestion);

		// Cargar la primera pregunta al iniciar la página
		window.onload = loadQuestion;

	</script>

</body>

</html>