<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entrena R</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Estilos base para el modo claro */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f4f7f6;
            color: #333;
            /* Texto oscuro por defecto */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Transici贸n suave para cambio de modo */
        }

        .quiz-container {
            background-color: #ffffff;
            /* Fondo blanco */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 700px;
            width: 100%;
            text-align: center;
            position: relative;
            /* Necesario para posicionar el bot贸n de modo oscuro */
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            /* Transici贸n suave */
        }

        .app-title {
            font-size: 2.5em;
            /* T铆tulo m谩s grande */
            font-weight: bold;
            margin-bottom: 5px;
            /* Espacio antes del subt铆tulo */
            color: #333;
        }

        .app-subtitle {
            font-size: 1em;
            color: #555;
            margin-bottom: 20px;
            /* Espacio despu茅s del subt铆tulo */
        }

        .question {
            margin-bottom: 20px;
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            text-align: left;
        }

        .options {
            text-align: left;
        }

        .options label {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            position: relative;
            padding-left: 35px;
            color: #333;
            /* Color de texto por defecto */
        }

        .options label:hover {
            background-color: #ffeacc;
            /* Naranja claro para hover */
            border-color: #ff9800;
            /* Naranja para el borde en hover */
        }

        /* Ocultar el radio button nativo */
        .options input[type="radio"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Crear el cuadrado personalizado */
        .options label::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #007bff;
            border-radius: 4px;
            background-color: #fff;
            transition: all 0.3s ease;
        }

        /* Estilo para el cuadrado cuando el radio button est谩 seleccionado */
        .options input[type="radio"]:checked+label::before {
            background-color: #007bff;
            border-color: #007bff;
        }

        /* Estilo para el punto interior del cuadrado */
        .options label::after {
            content: '';
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Mostrar el punto interior cuando el radio button est谩 seleccionado */
        .options input[type="radio"]:checked+label::after {
            opacity: 1;
        }


        .feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
        }

        .feedback.correct {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }

        .feedback.incorrect {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        .feedback.warning {
            background-color: #fff3cd;
            color: #856404;
            border-color: #ffeeba;
        }

        .explanation {
            margin-top: 10px;
            font-size: 0.95em;
            color: #555;
        }

        .score-container {
            margin-top: 20px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .score-button {
            font-size: 1em;
            font-weight: bold;
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            color: #ffffff;
            display: inline-block;
        }

        .score-button.attempted {
            background-color: #007bff;
            /* Azul para Intentadas */
        }

        .score-button.correct {
            background-color: #28a745;
            /* Verde para Correctas */
        }

        .score-button.incorrect {
            background-color: #ff9800;
            /* Naranja para Incorrectas */
        }


        .button {
            @apply text-white font-bold py-2 px-4 rounded-lg mt-4 transition duration-0;
            /* Transici贸n m谩s r谩pida */
            width: auto;
            display: block;
            margin-left: auto;
            margin-right: auto;
            background-color: #007bff;
            color: #ffffff;
            border: 2px solid #0056b3;
            cursor: pointer;
            text-decoration: none;
            padding: 10px 20px;
        }

        .button:disabled {
            @apply bg-gray-400 hover:bg-gray-400 cursor-not-allowed;
            border-color: #6b7280;
        }

        .button:hover:not(:disabled) {
            background-color: #0056b3;
            border-color: #003f80;
        }

        /* Estilo para el mensaje final del quiz */
        .quiz-container h2 {
            color: #007bff;
        }


        .timer {
            font-size: 1.5em;
            font-weight: bold;
            color: #ff9800;
            margin-bottom: 15px;
            padding: 10px;
            border: 2px solid #ff9800;
            border-radius: 8px;
            display: inline-block;
        }

        .end-message {
            margin-top: 20px;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
        }

        .summary-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: left;
        }

        body.dark-mode .summary-section {
            border-top-color: #4a5568;
            /* Borde separador oscuro */
        }


        .summary-section h3 {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #007bff;
            text-align: center;
        }

        body.dark-mode .summary-section h3 {
            color: #007bff;
            /* Azul para t铆tulo del resumen */
        }

        .summary-item {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        body.dark-mode .summary-item {
            background-color: #2d3748;
            border-color: #4a5568;
        }


        .summary-item strong {
            color: #333;
        }

        body.dark-mode .summary-item strong {
            color: #e2e8f0;
            /* Texto de pregunta claro */
        }


        .summary-item .correct-answer {
            margin-top: 5px;
            font-weight: bold;
            color: #155724;
        }

        body.dark-mode .summary-item .correct-answer {
            color: #48bb78;
            /* Verde en modo oscuro */
        }


        .summary-item .explanation {
            margin-top: 5px;
            font-size: 0.9em;
            color: #555;
        }

        body.dark-mode .summary-item .explanation {
            color: #cbd5e0;
            /* Texto de explicaci贸n claro */
        }


        /* Estilos para el modo oscuro */
        body.dark-mode {
            background-color: #1a202c;
            /* Fondo oscuro */
            color: #e2e8f0;
            /* Texto claro */
        }

        body.dark-mode .quiz-container {
            background-color: #2d3748;
            /* Fondo oscuro para el contenedor */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode h1 {
            /* Ajustar color del t铆tulo principal en modo oscuro */
            color: #e2e8f0;
        }

        body.dark-mode .question {
            color: #e2e8f0;
            /* Texto de pregunta claro */
        }

        body.dark-mode .options label {
            border-color: #4a5568;
            /* Borde m谩s oscuro */
            color: #e2e8f0;
            /* Texto de opci贸n claro */
        }

        body.dark-mode .options label:hover {
            background-color: #4a5568;
            /* Fondo oscuro en hover */
            border-color: #007bff;
            /* Borde azul en hover */
        }

        body.dark-mode .options label::before {
            border-color: #007bff;
            /* Borde azul */
            background-color: #2d3748;
            /* Fondo oscuro */
        }

        body.dark-mode .options input[type="radio"]:checked+label::before {
            background-color: #007bff;
            /* Fondo azul seleccionado */
            border-color: #007bff;
        }

        body.dark-mode .options label::after {
            background-color: #e2e8f0;
            /* Punto interior claro */
        }

        body.dark-mode .feedback.correct {
            background-color: #48bb78;
            /* Verde m谩s oscuro */
            color: #1a202c;
            /* Texto oscuro */
            border-color: #38a169;
        }

        body.dark-mode .feedback.incorrect {
            background-color: #f56565;
            /* Rojo m谩s oscuro */
            color: #1a202c;
            /* Texto oscuro */
            border-color: #e53e3e;
        }

        body.dark-mode .feedback.warning {
            background-color: #f6e05e;
            /* Amarillo m谩s oscuro */
            color: #2d3748;
            /* Texto oscuro */
            border-color: #d69e2e;
        }

        body.dark-mode .explanation {
            color: #cbd5e0;
            /* Texto de explicaci贸n claro */
        }

        body.dark-mode .quiz-container h2 {
            color: #007bff;
            /* Azul para t铆tulo final */
        }

        body.dark-mode .quiz-container .score-button.attempted {
            background-color: #007bff;
            /* Azul para Intentadas */
        }

        body.dark-mode .quiz-container .score-button.correct {
            background-color: #48bb78;
            /* Verde en modo oscuro */
        }

        body.dark-mode .quiz-container .score-button.incorrect {
            background-color: #ff9800;
            /* Naranja en modo oscuro */
        }

        body.dark-mode .timer {
            color: #ff9800;
            /* Naranja para el temporizador */
            border-color: #ff9800;
        }

        body.dark-mode .end-message {
            color: #e2e8f0;
            /* Texto claro */
        }

        body.dark-mode .summary-section {
            border-top-color: #4a5568;
            /* Borde separador oscuro */
        }

        body.dark-mode .summary-section h3 {
            color: #007bff;
            /* Azul para t铆tulo del resumen */
        }

        body.dark-mode .summary-item {
            background-color: #2d3748;
            border-color: #4a5568;
        }

        body.dark-mode .summary-item strong {
            color: #e2e8f0;
            /* Texto de pregunta claro */
        }

        body.dark-mode .summary-item .correct-answer {
            color: #48bb78;
            /* Verde en modo oscuro */
        }

        body.dark-mode .summary-item .explanation {
            color: #cbd5e0;
            /* Texto de explicaci贸n claro */
        }

        /* Estilo para el bot贸n de modo oscuro */
        #dark-mode-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: #007bff;
            /* Fondo azul */
            color: white;
            border: none;
            border-radius: 50%;
            /* Bot贸n redondo */
            width: 35px;
            height: 35px;
            font-size: 1em;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 10;
            /* Asegurar que est茅 por encima de otros elementos */
        }

        #dark-mode-toggle:hover {
            background-color: #0056b3;
            /* Azul m谩s oscuro en hover */
            transform: scale(1.05);
        }

        body.dark-mode #dark-mode-toggle {
            background-color: #007bff;
            /* Mantener azul en modo oscuro */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode #dark-mode-toggle:hover {
            background-color: #0056b3;
            /* Mantener azul m谩s oscuro en hover */
        }

        /* Estilos para las pesta帽as */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        body.dark-mode .tabs {
            border-bottom-color: #4a5568;
        }

        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            border-bottom: 2px solid transparent;
            transition: color 0.3s ease, border-bottom-color 0.3s ease;
        }

        body.dark-mode .tab-button {
            color: #b0b0b0;
        }

        .tab-button:hover {
            color: #007bff;
            border-bottom-color: #007bff;
        }

        body.dark-mode .tab-button:hover {
            color: #007bff;
            border-bottom-color: #007bff;
        }


        .tab-button.active {
            color: #007bff;
            border-bottom-color: #007bff;
        }

        body.dark-mode .tab-button.active {
            color: #007bff;
            border-bottom-color: #007bff;
        }


        .tab-content {
            display: none;
            /* Ocultar contenido de pesta帽a por defecto */
            padding-top: 20px;
        }

        .tab-content.active {
            display: block;
            /* Mostrar contenido de la pesta帽a activa */
        }


        /* Mensaje de usabilidad para el progreso */
        .usability-message {
            font-size: 0.85em;
            color: #555;
            margin-top: 20px;
            text-align: center;
        }

        body.dark-mode .usability-message {
            color: #b0b0b0;
            /* Gris claro */
        }

        /* Contenedor para el historial de sesiones */
        .session-history-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: left;
        }

        body.dark-mode .session-history-container {
            border-top-color: #424242;
        }

        .session-history-container h3 {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #007bff;
            text-align: center;
        }

        body.dark-mode .session-history-container h3 {
            color: #007bff;
            /* Azul */
        }

        .session-item {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        body.dark-mode .session-item {
            background-color: #2d2d2d;
            border-color: #424242;
        }

        .session-item p {
            margin-bottom: 5px;
            color: #333;
        }

        body.dark-mode .session-item p {
            color: #e0e0e0;
            /* Texto claro */
        }

        .session-item .score-detail {
            font-size: 0.95em;
            color: #555;
        }

        body.dark-mode .session-item .score-detail {
            color: #b0b0b0;
            /* Gris claro */
        }

        /* Estilos para el 谩rea del gr谩fico */
        .progress-chart-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
        }

        body.dark-mode .progress-chart-container {
            border-top-color: #424242;
        }

        .progress-chart-container h3 {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #007bff;
        }

        body.dark-mode .progress-chart-container h3 {
            color: #007bff;
            /* Azul */
        }

        .progress-chart-container svg {
            background-color: #f9f9f9;
            /* Fondo claro para el gr谩fico */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .progress-chart-container svg {
            background-color: #2d2d2d;
            /* Fondo oscuro para el gr谩fico */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .progress-chart-container .axis text {
            font-size: 0.8em;
            fill: #333;
            /* Color de texto del eje */
        }

        body.dark-mode .progress-chart-container .axis text {
            fill: #e0e0e0;
            /* Color de texto del eje en modo oscuro */
        }

        .progress-chart-container .axis path,
        .progress-chart-container .axis line {
            stroke: #888;
            /* Color de las l铆neas del eje */
        }

        body.dark-mode .progress-chart-container .axis path,
        body.dark-mode .progress-chart-container .axis line {
            stroke: #b0b0b0;
            /* Color de las l铆neas del eje en modo oscuro */
        }

        .progress-chart-container .line-correct {
            fill: none;
            stroke: #4caf50;
            /* Verde para l铆nea correcta */
            stroke-width: 2;
        }

        .progress-chart-container .line-incorrect {
            fill: none;
            stroke: #ff9800;
            /* Naranja para l铆nea incorrecta */
            stroke-width: 2;
        }

        .progress-chart-container .dot {
            fill: white;
            /* Fondo blanco para los puntos */
            stroke: #333;
            /* Borde oscuro para los puntos */
        }

        body.dark-mode .progress-chart-container .dot {
            fill: #1a202c;
            /* Fondo oscuro para los puntos */
            stroke: #e2e8f0;
            /* Borde claro para los puntos */
        }


        /* Eliminar estilos de tooltip si no se usa */
        /*
          .progress-chart-container .tooltip {
              position: absolute;
              text-align: center;
              padding: 8px;
              font: 12px sans-serif;
              background: lightsteelblue;
              border: 0px;
              border-radius: 8px;
              pointer-events: none;
              color: #333;
              z-index: 100;
          }
          */

        /* Estilos para la secci贸n de configuraci贸n */
        .config-section {
            margin-top: 20px;
            text-align: left;
            padding: 20px;
            border: 1px solid #eee;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        body.dark-mode .config-section {
            border-color: #4a5568;
            background-color: #2d3748;
        }

        .config-section h3 {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #007bff;
            text-align: center;
        }

        body.dark-mode .config-section h3 {
            color: #007bff;
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-item label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        body.dark-mode .config-item label {
            color: #e2e8f0;
        }

        .config-item input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            color: #333;
        }

        body.dark-mode .config-item input[type="number"] {
            border-color: #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
        }

        .start-button {
            /* Reutilizar estilos del bot贸n general pero con posibles ajustes */
            @apply bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mt-4 transition duration-0;
            background-color: #28a745;
            /* Verde */
            border-color: #218838;
            /* Verde m谩s oscuro */
        }

        body.dark-mode .start-button {
            background-color: #48bb78;
            /* Verde en modo oscuro */
            border-color: #38a169;
        }

        body.dark-mode .start-button:hover {
            background-color: #38a169;
            border-color: #2b7d4b;
        }
    </style>
</head>

<body>

    <div class="quiz-container">
        <button id="dark-mode-toggle"></button>
        <h1 class="app-title">Entrena R</h1>
        <p class="app-subtitle">Configura tu entrenamiento y revisa tu progreso.</p>

        <div class="tabs">
            <button class="tab-button active" data-tab="config-tab">Configuraci贸n</button>
            <button class="tab-button" data-tab="quiz-tab">Entrenamiento</button>
            <button class="tab-button" data-tab="progress-tab">Progreso</button>
        </div>

        <div id="config-tab" class="tab-content active">
            <div class="config-section">
                <h3>Configurar Entrenamiento</h3>
                <div class="config-item">
                    <label for="num-questions">N煤mero de Preguntas:</label>
                    <input type="number" id="num-questions" value="10" min="1" max="10">
                </div>
                <div class="config-item">
                    <label for="quiz-time">Tiempo (segundos):</label>
                    <input type="number" id="quiz-time" value="60" min="10" max="300">
                </div>
                <button id="start-quiz-button" class="button start-button">Iniciar Entrenamiento</button>
            </div>
        </div>


        <div id="quiz-tab" class="tab-content">
            <div class="timer" id="timer-area">Tiempo restante: 60s</div>

            <div id="quiz-content">
                <div id="question-area">
                    <div class="question" id="question-text"></div>
                    <div class="options" id="options-area">
                    </div>
                </div>

                <button id="submit-answer" class="button">Responder</button>
                <button id="next-question" class="button hidden">Siguiente pregunta</button>

                <div id="feedback-area" class="feedback hidden">
                </div>
            </div>

            <div class="score-container" id="score-area">
            </div>

            <div id="end-screen" class="hidden">
                <button id="restart-quiz" class="button hidden">Reiniciar prueba</button>
            </div>
        </div>

        <div id="progress-tab" class="tab-content">
            <div class="session-history-container">
                <h3 id="session-history-title">Historial de Sesi贸n</h3>
                <div id="session-history-list">
                </div>
                <button id="clear-history-button" class="button">Borrar Historial</button>
                <p class="usability-message">Tu progreso se guarda en tu navegador hasta que borres el historial o uses
                    otro dispositivo.</p>
            </div>

            <div class="progress-chart-container hidden">
                <h3>Progreso de Intentos</h3>
                <div id="progress-chart">
                </div>
            </div>
            <button id="download-csv-button" class="button mt-4">Descargar Historial (CSV)</button>
        </div>


    </div>

    <script>
        // Array de objetos para almacenar las preguntas, opciones, respuestas correctas y explicaciones.
        // Basado en el contenido proporcionado por el usuario.
        const originalQuizData = [ // Mantener una copia original para reiniciar
            {
                question: "驴Cu谩l es la funci贸n principal del men煤 'Publish' en el contexto de R Markdown o Quarto?",
                options: {
                    A: "Ejecutar todos los chunks de c贸digo del documento.",
                    B: "Formatear autom谩ticamente el c贸digo fuente del documento.",
                    C: "Compartir el documento renderizado en servicios online como RPubs.",
                    D: "Guardar el documento en un formato espec铆fico como PDF o Word."
                },
                correctAnswer: "C",
                explanation: "La funci贸n del men煤 Publish es precisamente permitir a los usuarios compartir sus documentos renderizados en servicios en l铆nea como RPubs, lo que simplifica la difusi贸n de an谩lisis y resultados a una audiencia m谩s amplia."
            },
            {
                question: "驴Qu茅 indica el bot贸n 'Outline' en el editor de R Markdown o Quarto y c贸mo se activa?",
                options: {
                    A: "Indica los errores de sintaxis en el c贸digo R; se activa al guardar el archivo.",
                    B: "Muestra una vista previa del documento final renderizado; se activa con CTRL+Enter.",
                    C: "Indica la estructura de carpetas del proyecto; se activa en el men煤 'File'.",
                    D: "Muestra un esquema navegable del documento basado en encabezados Markdown; se activa haciendo clic en su bot贸n en la interfaz."
                },
                correctAnswer: "D",
                explanation: "El bot贸n Outline muestra un esquema navegable del documento, construido a partir de los encabezados formateados con Markdown. Se activa simplemente haciendo clic en el bot贸n correspondiente en la interfaz del editor, facilitando la navegaci贸n y comprensi贸n de la estructura."
            },
            {
                question: "Describe la funci贸n de los botones 'Source' y 'Visual' en el editor.",
                options: {
                    A: "'Source' es para ver el c贸digo R y 'Visual' es para ver los gr谩ficos generados.",
                    B: "'Source' es para editar archivos de datos y 'Visual' es para editar el texto.",
                    C: "Permiten alternar entre la vista del c贸digo fuente Markdown y una vista WYSIWYG (Lo que ves es lo que obtienes) m谩s amigable para la edici贸n.",
                    D: "'Source' compila el documento y 'Visual' lo abre en el navegador."
                },
                correctAnswer: "C",
                explanation: "Los botones Source y Visual son fundamentales para la edici贸n, permitiendo alternar f谩cilmente entre la manipulaci贸n directa del c贸digo fuente Markdown y una vista m谩s visual y amigable (WYSIWYG), adapt谩ndose a diferentes preferencias de edici贸n."
            },
            {
                question: "驴C贸mo se genera un documento final (renderizado) en R Markdown o Quarto, y qu茅 opciones de formato de salida existen?",
                options: {
                    A: "Se utiliza el comando render() en la consola de R; solo se puede generar HTML por defecto.",
                    B: "Se guarda el archivo y se utiliza el bot贸n 'Knit' o 'Render'; solo se pueden generar PDF y Word.",
                    C: "Se ejecuta el c贸digo R del documento; el formato de salida es siempre texto plano.",
                    D: "Se guarda el archivo y se utiliza el icono de 'renderizado', pudiendo elegir formatos como HTML, PDF o Word (especificados en YAML), con PDF requiriendo LaTeX."
                },
                correctAnswer: "D",
                explanation: "Para generar el documento final, se guarda el archivo y se usa el icono de renderizado. El tri谩ngulo junto a 茅l permite elegir formatos de salida como HTML, PDF o Word, siempre que est茅n definidos en el encabezado YAML. Es importante recordar que PDF requiere la instalaci贸n de LaTeX."
            },
            {
                question: "驴Qu茅 es un chunk en R Markdown o Quarto y cu谩l es su prop贸sito principal?",
                options: {
                    A: "Es una secci贸n de texto narrativo con formato especial.",
                    B: "Es un bloque de configuraci贸n inicial del documento (YAML).",
                    C: "Es un bloque de c贸digo R incrustado, delimitado por marcadores, cuyo prop贸sito es ejecutar c贸digo y mostrar sus resultados en el documento.",
                    D: "Es un enlace a un recurso externo o una imagen."
                },
                correctAnswer: "C",
                explanation: "Un chunk es la parte central de la reproducibilidad: un bloque de c贸digo R (u otro lenguaje en Quarto) delimitado por ```{r} y ``` que se ejecuta durante el renderizado para incluir los resultados (c贸digo, texto, tablas, gr谩ficos) directamente en el documento final."
            },
            {
                question: "Menciona dos formas de insertar un nuevo chunk de c贸digo en el editor.",
                options: {
                    A: "Copiar y pegar un chunk existente; usar el men煤 'Edit'.",
                    B: "Escribir manualmente los delimitadores ``` y {r}; usar la consola de R.",
                    C: "Usar el atajo de teclado CTRL+ALT+I; hacer clic en el icono 'Insert a new code chunk' en la barra de herramientas.",
                    D: "Usar el men煤 'Tools'; arrastrar y soltar un script R."
                },
                correctAnswer: "C",
                explanation: "Las dos formas m谩s directas y eficientes de insertar un chunk son mediante el atajo de teclado universal CTRL+ALT+I o haciendo clic en el icono dedicado ('Insert a new code chunk') en la barra de herramientas del editor."
            },
            {
                question: "驴Qu茅 diferencia existe entre las opciones de chunk echo: false e include: false?",
                options: {
                    A: "echo: false oculta los resultados del c贸digo, mientras que include: false oculta solo el c贸digo fuente.",
                    B: "echo: false se usa para texto, include: false se usa para c贸digo.",
                    C: "echo: false ejecuta el c贸digo pero oculta el c贸digo fuente en el documento final; include: false ejecuta el c贸digo pero oculta tanto el c贸digo fuente como sus resultados.",
                    D: "echo: false detiene la ejecuci贸n del chunk, mientras que include: false la permite."
                },
                correctAnswer: "C",
                explanation: "La distinci贸n es crucial para controlar qu茅 se muestra en el documento. echo: false es 煤til cuando quieres mostrar solo el resultado de un c谩lculo o gr谩fico sin el c贸digo que lo gener贸. include: false oculta todo del chunk, 煤til para c贸digo que genera objetos que se usan m谩s adelante pero no necesitas mostrar."
            },
            {
                question: "驴Cu谩l es la funci贸n principal del paquete Shiny y cu谩ndo se lanz贸 su primera versi贸n beta p煤blica?",
                options: {
                    A: "Es un paquete para crear informes est谩ticos y publicarlos en RPubs; lanzado en 2010.",
                    B: "Es un paquete para limpiar y transformar datos de manera eficiente; lanzado en 2015.",
                    C: "Permite la creaci贸n de aplicaciones web interactivas y dashboards directamente desde R; su primera versi贸n beta p煤blica se lanz贸 en 2013.",
                    D: "Es una extensi贸n de R Markdown para generar presentaciones; lanzado en 2018."
                },
                correctAnswer: "C",
                explanation: "Shiny revolucion贸 la capacidad de los usuarios de R para compartir resultados, permitiendo construir potentes aplicaciones web interactivas y dashboards sin necesidad de conocimientos avanzados de desarrollo web. Su lanzamiento beta en 2013 marc贸 un hito importante."
            },
            {
                question: "Describe brevemente la separaci贸n entre las capas UI (interfaz de usuario) y Server en una aplicaci贸n Shiny.",
                options: {
                    A: "La capa UI contiene el c贸digo R, y la capa Server define el dise帽o visual.",
                    B: "La capa UI maneja la l贸gica de base de datos, y la capa Server maneja la visualizaci贸n.",
                    C: "Ambas capas contienen el mismo tipo de c贸digo R, pero se ejecutan en paralelo.",
                    D: "La capa UI define la apariencia y los elementos interactivos (inputs/outputs), mientras que la capa Server contiene la l贸gica de R que procesa datos y genera las salidas en respuesta a las interacciones."
                },
                correctAnswer: "D",
                explanation: "Esta separaci贸n es el coraz贸n de la arquitectura Shiny. UI se encarga de lo que el usuario ve e interact煤a (botones, sliders, placeholders para gr谩ficos), mientras que Server es el 'cerebro' que realiza los c谩lculos, filtra datos, genera gr谩ficos y actualiza los elementos en la UI bas谩ndose en la actividad del usuario."
            },
            {
                question: "驴Qu茅 significa el concepto de 'reactividad' en el contexto de Shiny?",
                options: {
                    A: "La capacidad de la aplicaci贸n para conectarse a diferentes bases de datos.",
                    B: "La velocidad con la que el c贸digo R se ejecuta en el servidor.",
                    C: "La habilidad de la aplicaci贸n para generar informes PDF de forma autom谩tica.",
                    D: "La capacidad de la aplicaci贸n para actualizar autom谩ticamente partes de la interfaz de usuario (outputs) en respuesta a cambios en las entradas del usuario (inputs) o datos, sin recargar la p谩gina completa."
                },
                correctAnswer: "D",
                explanation: "La reactividad es la caracter铆stica distintiva de Shiny que permite crear experiencias de usuario din谩micas e interactivas. Los outputs 'reaccionan' a los cambios en los inputs del usuario, actualiz谩ndose en tiempo real, lo que facilita la exploraci贸n de datos interactiva."
            }
        ];

        let shuffledQuizData = []; // Array para almacenar las preguntas aleatorizadas
        let currentQuestionIndex = 0; // ndice de la pregunta actual
        let score = 0; // Puntaje del usuario (solo correctas)
        let timerInterval; // Variable para almacenar el intervalo del temporizador
        let totalQuizTime = 60; // Tiempo total en segundos para todo el quiz (configurable)
        let numberOfQuestions = 10; // Cantidad de preguntas a mostrar (configurable)
        let timeLeft = totalQuizTime; // Tiempo restante total del quiz
        let quizActive = true; // Bandera para saber si el quiz est谩 activo

        // Obtener referencias a los elementos del DOM - 隆Ahora dentro de window.onload!
        let questionTextElement;
        let optionsAreaElement;
        let submitButton;
        let nextButton;
        let restartButton;
        let feedbackAreaElement;
        let scoreAttemptedButton; // Bot贸n para Intentadas
        let scoreCorrectButton;   // Bot贸n para Correctas
        let scoreIncorrectButton; // Bot贸n para Incorrectas
        let timerAreaElement;
        let quizContentElement;
        let endScreenElement;
        let scoreContainerElement; // Contenedor de los botones de puntaje
        let darkModeToggle; // Bot贸n de modo oscuro
        let sessionHistoryList; // Lista para el historial de sesiones
        let clearHistoryButton; // Bot贸n para borrar historial
        let progressChartContainer; // Contenedor del gr谩fico de progreso
        let progressChartElement; // Elemento donde se dibuja el gr谩fico
        let tabButtons; // Botones de pesta帽a
        let tabContents; // Contenido de las pesta帽as
        let downloadCsvButton; // Bot贸n de descarga CSV
        let numQuestionsInput; // Input para n煤mero de preguntas
        let quizTimeInput; // Input para tiempo del quiz
        let startQuizButton; // Bot贸n para iniciar quiz desde config


        // Funci贸n para mezclar un array (Algoritmo Fisher-Yates (Knuth) Shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Intercambiar elementos
            }
            return array;
        }

        // Funci贸n para mezclar las opciones de un objeto de opciones
        function shuffleOptions(optionsObject) {
            const optionKeys = Object.keys(optionsObject);
            shuffleArray(optionKeys); // Mezclar las claves (A, B, C, D)
            const shuffledOptions = {};
            optionKeys.forEach(key => {
                shuffledOptions[key] = optionsObject[key]; // Reconstruir el objeto con el orden mezclado
            });
            return shuffledOptions;
        }


        // Funci贸n para iniciar el temporizador global del quiz
        function startGlobalTimer() {
            timeLeft = totalQuizTime; // Reiniciar tiempo total con el valor configurado
            timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`; // Mostrar tiempo inicial

            // Limpiar cualquier temporizador existente antes de iniciar uno nuevo
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            timerInterval = setInterval(() => {
                timeLeft--;
                timerAreaElement.textContent = `Tiempo restante: ${timeLeft}s`;

                if (timeLeft <= 0) {
                    clearInterval(timerInterval); // Detener el temporizador
                    endQuiz(true); // Finalizar el quiz porque el tiempo se agot贸
                }
            }, 1000); // Actualizar cada 1 segundo
        }

        // Funci贸n para detener el temporizador
        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Funci贸n para cargar y mostrar la pregunta actual
        function loadQuestion() {
            if (!quizActive) return; // No cargar pregunta si el quiz no est谩 activo

            // Limpiar 谩rea de opciones y feedback
            optionsAreaElement.innerHTML = '';
            feedbackAreaElement.innerHTML = '';
            feedbackAreaElement.classList.add('hidden'); // Ocultar feedback
            feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning'); // Limpiar clases de feedback

            // Asegurarse de que el contenido del quiz est茅 visible y la pantalla final oculta
            quizContentElement.classList.remove('hidden');
            endScreenElement.classList.add('hidden');
            timerAreaElement.classList.remove('hidden'); // Asegurarse de que el temporizador sea visible
            scoreContainerElement.classList.remove('hidden'); // Asegurarse de que el contenedor de puntaje sea visible
            progressChartContainer.classList.add('hidden'); // Ocultar el gr谩fico de progreso


            // Habilitar las opciones de respuesta al cargar una nueva pregunta
            enableOptions();

            // Deseleccionar cualquier radio button previamente seleccionado
            const selectedRadio = optionsAreaElement.querySelector('input[name="answer"]:checked');
            if (selectedRadio) {
                selectedRadio.checked = false;
            }


            // Obtener la pregunta actual del array de preguntas aleatorizadas
            // Asegurarse de no exceder el n煤mero de preguntas configurado
            if (currentQuestionIndex >= numberOfQuestions || currentQuestionIndex >= shuffledQuizData.length) {
                endQuiz(false); // Finalizar si ya se mostraron todas las preguntas configuradas o disponibles
                return;
            }

            const currentQuestion = shuffledQuizData[currentQuestionIndex];

            // Mostrar el texto de la pregunta
            questionTextElement.textContent = currentQuestion.question;

            // Mezclar las opciones de la pregunta actual
            const shuffledOptions = shuffleOptions(currentQuestion.options);

            // Crear y mostrar las opciones de respuesta mezcladas
            for (const optionKey in shuffledOptions) {
                if (shuffledOptions.hasOwnProperty(optionKey)) {
                    const optionValue = shuffledOptions[optionKey];

                    // Crear un div para cada opci贸n para mejor estructura y padding
                    const optionDiv = document.createElement('div');

                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'answer'; // Mismo nombre para que solo una opci贸n sea seleccionable
                    input.value = optionKey;
                    input.id = `option-${optionKey}`; // ID 煤nico para la etiqueta

                    const label = document.createElement('label');
                    label.textContent = `${optionKey}) ${optionValue}`;
                    label.htmlFor = `option-${optionKey}`; // Asociar etiqueta con input

                    // A帽adir input y label al div de la opci贸n
                    optionDiv.appendChild(input);
                    optionDiv.appendChild(label);

                    // A帽adir el div de la opci贸n al 谩rea de opciones
                    optionsAreaElement.appendChild(optionDiv);
                }
            }

            // Mostrar el bot贸n de responder y ocultar el de siguiente
            submitButton.classList.remove('hidden');
            nextButton.classList.add('hidden');

            // Habilitar el bot贸n de responder
            submitButton.disabled = false;

            // Actualizar el puntaje mostrado (Intentadas, Correctas, Incorrectas)
            updateScoreDisplay();

            // Deshabilitar opciones si el tiempo se agot贸 (aunque endQuiz deber铆a manejar esto)
            if (timeLeft <= 0) {
                disableOptions();
                submitButton.disabled = true;
            }
        }

        // Funci贸n para deshabilitar las opciones de respuesta
        function disableOptions() {
            const options = optionsAreaElement.querySelectorAll('input[name="answer"]');
            options.forEach(option => {
                option.disabled = true;
            });
        }

        // Funci贸n para habilitar las opciones de respuesta
        function enableOptions() {
            const options = optionsAreaElement.querySelectorAll('input[name="answer"]');
            options.forEach(option => {
                option.disabled = false;
            });
        }


        // Funci贸n para verificar la respuesta seleccionada
        function checkAnswer() {
            if (!quizActive) return; // No procesar respuesta si el quiz no est谩 activo

            // Obtener la opci贸n seleccionada por el usuario
            const selectedOption = document.querySelector('input[name="answer"]:checked');

            // Si no se seleccion贸 ninguna opci贸n, mostrar un mensaje y no continuar
            if (!selectedOption) {
                feedbackAreaElement.classList.remove('hidden');
                feedbackAreaElement.classList.remove('correct', 'incorrect'); // Limpiar clases
                feedbackAreaElement.classList.add('warning'); // Usar la clase warning para este tipo de mensaje
                feedbackAreaElement.innerHTML = '<strong>Por favor, selecciona una opci贸n antes de responder.</strong>';
                return; // Salir de la funci贸n si no hay selecci贸n
            }

            // Deshabilitar el bot贸n de responder para evitar m煤ltiples env铆os
            submitButton.disabled = true;
            disableOptions(); // Deshabilitar opciones despu茅s de responder

            let userAnswer = selectedOption.value;


            // Obtener la respuesta correcta de la pregunta actual (del array mezclado)
            const correctAnswer = shuffledQuizData[currentQuestionIndex].correctAnswer;
            const explanation = shuffledQuizData[currentQuestionIndex].explanation;

            // Mostrar el 谩rea de feedback
            feedbackAreaElement.classList.remove('hidden');

            // Limpiar clases de feedback previas
            feedbackAreaElement.classList.remove('correct', 'incorrect', 'warning');

            // Comprobar si la respuesta es correcta
            if (userAnswer === correctAnswer) {
                score++; // Incrementar puntaje si es correcta
                feedbackAreaElement.classList.add('correct');
                feedbackAreaElement.innerHTML = '<strong>隆Correcto!</strong>';
            } else {
                feedbackAreaElement.classList.add('incorrect');
                feedbackAreaElement.innerHTML = `<strong>Incorrecto.</strong> La respuesta correcta es ${correctAnswer}.`;
            }

            // A帽adir la explicaci贸n al feedback
            const explanationElement = document.createElement('p');
            explanationElement.classList.add('explanation');
            explanationElement.textContent = explanation;
            feedbackAreaElement.appendChild(explanationElement);

            // Ocultar el bot贸n de responder y mostrar el de siguiente
            submitButton.classList.add('hidden');
            // Solo mostrar el bot贸n siguiente si el tiempo no se ha agotado
            if (timeLeft > 0) {
                nextButton.classList.remove('hidden');
            } else {
                // Si el tiempo se agot贸, ir directamente a la pantalla final
                endQuiz(true);
            }


            // Actualizar la visualizaci贸n del puntaje (despu茅s de incrementar el score si fue correcta)
            updateScoreDisplay();
        }

        // Funci贸n para pasar a la siguiente pregunta o finalizar el quiz
        function nextQuestion() {
            if (!quizActive) return; // No pasar de pregunta si el quiz no est谩 activo

            currentQuestionIndex++; // Incrementar el 铆ndice de la pregunta

            // Verificar si hay m谩s preguntas (en el array mezclado, hasta el l铆mite configurado) y si el tiempo no se ha agotado
            if (currentQuestionIndex < numberOfQuestions && currentQuestionIndex < shuffledQuizData.length && timeLeft > 0) {
                loadQuestion(); // Cargar la siguiente pregunta
            } else {
                endQuiz(false); // Finalizar el quiz (ya sea por terminar preguntas o por tiempo agotado)
            }
        }

        // Funci贸n para actualizar la visualizaci贸n del puntaje
        function updateScoreDisplay() {
            // currentQuestionIndex es el n煤mero de preguntas que ya se han mostrado.
            // Si el bot贸n "Responder" est谩 visible, significa que la pregunta actual a煤n no se ha respondido,
            // por lo que el n煤mero de intentadas es igual al 铆ndice actual.
            // Si el bot贸n "Siguiente Pregunta" est谩 visible, significa que la pregunta actual ya se respondi贸,
            // por lo que el n煤mero de intentadas es el 铆ndice actual + 1.
            const attempted = currentQuestionIndex + (nextButton.classList.contains('hidden') ? 0 : 1);

            const correct = score;
            const incorrect = attempted - correct;

            // Actualizar el texto de los botones de puntaje
            scoreAttemptedButton.textContent = `Intentadas: ${attempted}`;
            scoreCorrectButton.textContent = `Correctas: ${correct}`;
            scoreIncorrectButton.textContent = `Incorrectas: ${incorrect}`;
        }

        // Funci贸n para finalizar el quiz
        function endQuiz(timeRanOut) {
            if (!quizActive) return; // Evitar finalizar m煤ltiples veces
            quizActive = false; // Marcar el quiz como inactivo

            // Detener el temporizador final
            stopTimer();
            timerAreaElement.classList.add('hidden'); // Ocultar el temporizador al finalizar

            // Ocultar el contenido del quiz
            quizContentElement.classList.add('hidden');
            scoreContainerElement.classList.add('hidden'); // Ocultar los botones de puntaje principales


            // Mostrar la pantalla final
            endScreenElement.classList.remove('hidden');

            // Mostrar mensaje de fin de quiz
            const endTitle = document.createElement('h2');
            endTitle.classList.add('text-xl', 'font-bold', 'text-center', 'text-gray-800', 'mb-4');
            if (timeRanOut) {
                endTitle.textContent = '隆Tiempo agotado!';
            } else {
                endTitle.textContent = '隆Entrenamiento Finalizado!'; // Cambiar texto
            }

            // Calcular el puntaje final detallado
            const totalAttempted = currentQuestionIndex; // Total de preguntas que se intentaron
            const finalCorrect = score;
            const finalIncorrect = totalAttempted - finalCorrect;


            // Determinar el mensaje basado en el puntaje
            let scoreMessageText = "";
            if (finalCorrect < 3) {
                scoreMessageText = "Sigue repasando el contenido, cada intento puedes mejorar.";
            } else if (finalCorrect >= 3 && finalCorrect < 5) {
                scoreMessageText = "隆Bien! Est谩s avanzando por el camino de R, sigue repasando.";
            } else { // finalCorrect >= 5
                scoreMessageText = "隆Sigue as铆! Est谩s aprendiendo a trabajar con R.";
            }

            const scoreMessageElement = document.createElement('p');
            scoreMessageElement.classList.add('end-message', 'text-center');
            scoreMessageElement.textContent = scoreMessageText;

            // Crear un nuevo contenedor para los botones de puntaje finales
            const finalScoreContainer = document.createElement('div');
            finalScoreContainer.classList.add('score-container'); // Reutilizar la clase de estilo


            // Crear y a帽adir los botones de puntaje finales
            const finalAttemptedButton = document.createElement('span');
            finalAttemptedButton.classList.add('score-button', 'attempted');
            finalAttemptedButton.textContent = `Intentadas: ${totalAttempted}`;
            finalScoreContainer.appendChild(finalAttemptedButton);

            const finalCorrectButton = document.createElement('span');
            finalCorrectButton.classList.add('score-button', 'correct');
            finalCorrectButton.textContent = `Correctas: ${finalCorrect}`;
            finalScoreContainer.appendChild(finalCorrectButton);

            const finalIncorrectButton = document.createElement('span');
            finalIncorrectButton.classList.add('score-button', 'incorrect');
            finalIncorrectButton.textContent = `Incorrectas: ${finalIncorrect}`;
            finalScoreContainer.appendChild(finalIncorrectButton);


            // Limpiar el contenido anterior de la pantalla final y a帽adir los nuevos elementos
            endScreenElement.innerHTML = '';
            endScreenElement.appendChild(endTitle);
            endScreenElement.appendChild(finalScoreContainer); // A帽adir el contenedor de botones de puntaje finales
            endScreenElement.appendChild(scoreMessageElement); // A帽adir el mensaje basado en el puntaje

            // --- Agregar la secci贸n de resumen de preguntas respondidas ---
            const summarySection = document.createElement('div');
            summarySection.classList.add('summary-section');

            const summaryTitle = document.createElement('h3');
            summaryTitle.textContent = 'Resumen de Preguntas Respondidas';
            summarySection.appendChild(summaryTitle);

            // Iterar solo sobre las preguntas que fueron presentadas en este quiz
            // currentQuestionIndex es el n煤mero de preguntas que se intentaron/vieron
            for (let i = 0; i < currentQuestionIndex; i++) {
                const questionData = shuffledQuizData[i]; // Obtener la pregunta del array mezclado

                const summaryItem = document.createElement('div');
                summaryItem.classList.add('summary-item');

                const questionText = document.createElement('p');
                questionText.innerHTML = `<strong>Pregunta ${i + 1}:</strong> ${questionData.question}`; // Usar i+1 para el n煤mero de pregunta en el resumen
                summaryItem.appendChild(questionText);

                const correctAnswer = document.createElement('p');
                // Encontrar el texto de la respuesta correcta usando la clave
                const correctAnswerText = questionData.options[questionData.correctAnswer];
                correctAnswer.innerHTML = `<span class="correct-answer">Respuesta Correcta: ${questionData.correctAnswer}) ${correctAnswerText}</span>`;
                summaryItem.appendChild(correctAnswer);

                const explanation = document.createElement('p');
                explanation.classList.add('explanation');
                explanation.textContent = `Explicaci贸n: ${questionData.explanation}`;
                summaryItem.appendChild(explanation);

                summarySection.appendChild(summaryItem);
            }


            endScreenElement.appendChild(summarySection); // A帽adir la secci贸n de resumen a la pantalla final
            // --- Fin de la secci贸n de resumen ---


            // Mostrar el bot贸n de reiniciar
            restartButton.classList.remove('hidden');
            endScreenElement.appendChild(restartButton); // A帽adir el bot贸n de reiniciar a la pantalla final

            // Asegurarse de que el 谩rea de puntaje principal est茅 oculta al mostrar el puntaje final en la pantalla final
            // scoreAreaElement.classList.add('hidden'); // Esto ya no es necesario ya que ocultamos scoreContainerElement

            // Guardar el resultado de la sesi贸n en localStorage
            saveSessionResult({
                attempted: totalAttempted,
                correct: finalCorrect,
                incorrect: finalIncorrect,
                timestamp: new Date().toISOString() // Opcional: guardar la hora del intento
            });

            // Enviar datos al backend (solo esqueleto)
            sendResultToBackend({
                attempted: totalAttempted,
                correct: finalCorrect,
                incorrect: finalIncorrect,
                timestamp: new Date().toISOString(),
                quizId: 'r_markdown_shiny_quiz' // Identificador del quiz
            });

            // Mostrar el gr谩fico de progreso al finalizar el quiz
            // progressChartContainer.classList.remove('hidden'); // Ya no se muestra aqu铆, se muestra en la pesta帽a Progreso
            // drawProgressChart(); // Ya no se dibuja aqu铆
        }

        // Funci贸n para guardar el resultado de la sesi贸n en localStorage
        function saveSessionResult(result) {
            const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
            results.push(result);
            localStorage.setItem('quizResults', JSON.stringify(results));
            displaySessionHistory(); // Actualizar la visualizaci贸n del historial
        }

        // Funci贸n para cargar y mostrar el historial de sesiones
        function displaySessionHistory() {
            const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
            sessionHistoryList.innerHTML = ''; // Limpiar la lista actual

            if (results.length === 0) {
                sessionHistoryList.innerHTML = '<p class="text-center text-gray-500">A煤n no hay intentos en esta sesi贸n.</p>';
                // Ocultar el gr谩fico si no hay historial
                progressChartContainer.classList.add('hidden');
                return;
            }

            results.forEach((result, index) => {
                const sessionItem = document.createElement('div');
                sessionItem.classList.add('session-item');
                sessionItem.innerHTML = `
                     <p><strong>Intento ${index + 1}:</strong></p>
                     <p class="score-detail">Intentadas: ${result.attempted}, Correctas: ${result.correct}, Incorrectas: ${result.incorrect}</p>
                     ${result.timestamp ? `<p class="score-detail">Hora: ${new Date(result.timestamp).toLocaleString()}</p>` : ''}
                 `;
                sessionHistoryList.appendChild(sessionItem);
            });

            // Mostrar el gr谩fico si hay historial
            progressChartContainer.classList.remove('hidden');
            drawProgressChart(); // Dibujar el gr谩fico con los datos del historial
        }

        // Funci贸n para borrar el historial de sesiones
        function clearSessionHistory() {
            localStorage.removeItem('quizResults');
            displaySessionHistory(); // Actualizar la visualizaci贸n (mostrar谩 el mensaje de "A煤n no hay intentos")
        }

        // Funci贸n para descargar el historial como archivo CSV
        function downloadCSV() {
            const results = JSON.parse(localStorage.getItem('quizResults') || '[]');

            if (results.length === 0) {
                alert("No hay historial para descargar.");
                return;
            }

            // Crear el encabezado del CSV
            const headers = ["Intento", "Intentadas", "Correctas", "Incorrectas", "Hora"];
            let csvContent = headers.join(",") + "\n";

            // A帽adir los datos de cada intento
            results.forEach((result, index) => {
                const row = [
                    index + 1,
                    result.attempted,
                    result.correct,
                    result.incorrect,
                    result.timestamp ? new Date(result.timestamp).toLocaleString() : '' // Formatear la hora
                ];
                csvContent += row.join(",") + "\n";
            });

            // Crear un Blob con el contenido CSV
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

            // Crear un enlace de descarga
            const link = document.createElement('a');
            if (link.download !== undefined) { // Verificar si el atributo download es soportado
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'historial_quiz_r.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // Fallback para navegadores que no soportan el atributo download
                alert("Tu navegador no soporta la descarga autom谩tica. Copia el siguiente texto:\n\n" + csvContent);
            }
        }


        // Funci贸n placeholder para enviar datos al backend
        function sendResultToBackend(resultData) {
            // ** ESTO ES SOLO UN ESQUELETO **
            // Para que esto funcione, necesitas un servidor backend configurado
            // para recibir peticiones POST en la URL especificada.
            const backendUrl = 'TU_URL_DEL_BACKEND_PARA_GUARDAR_RESULTADOS'; // <<< Reemplaza con tu URL real

            console.log('Intentando enviar datos al backend:', resultData); // Log para depuraci贸n

            // Descomenta el siguiente bloque para intentar enviar datos (requiere backend)
            /*
            fetch(backendUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(resultData),
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Error al enviar datos al backend:', response.statusText);
                }
                return response.json();
            })
            .then(data => {
                console.log('Respuesta del backend:', data);
            })
            .catch((error) => {
                console.error('Error en la conexi贸n con el backend:', error);
            });
            */
        }

        // Funci贸n para dibujar el gr谩fico de progreso usando D3.js (L铆nea y Punto)
        function drawProgressChart() {
            const results = JSON.parse(localStorage.getItem('quizResults') || '[]');
            progressChartElement.innerHTML = ''; // Limpiar el 谩rea del gr谩fico anterior

            if (results.length === 0) {
                // No dibujar gr谩fico si no hay datos
                return;
            }

            const data = results.map((r, i) => ({
                attempt: i + 1,
                correct: r.correct,
                incorrect: r.incorrect
            }));

            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            const width = 600 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            // Seleccionar el contenedor y a帽adir el SVG
            const svg = d3.select("#progress-chart").append("svg")
                .attr("width", "100%") // Usar ancho relativo
                .attr("height", height + margin.top + margin.bottom)
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // A帽adir viewBox para responsividad
                .attr("preserveAspectRatio", "xMidYMid meet") // Mantener aspecto
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Escalas
            const xScale = d3.scaleLinear() // Escala lineal para el eje X (intentos)
                .range([0, width])
                .domain([1, d3.max(data, d => d.attempt)]); // El eje X va desde 1 hasta el n煤mero m谩ximo de intentos

            const yScale = d3.scaleLinear()
                .range([height, 0])
                .domain([0, d3.max(data, d => d.correct + d.incorrect)]); // El eje Y va desde 0 hasta el total de intentadas

            // Eje X (con formato para mostrar n煤meros enteros de intentos)
            svg.append("g")
                .attr("class", "axis axis--x")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d"))); // Formato para enteros

            // Eje Y
            svg.append("g")
                .attr("class", "axis axis--y")
                .call(d3.axisLeft(yScale).tickFormat(d3.format("d"))); // Formato para enteros

            // Definir las l铆neas
            const lineCorrect = d3.line()
                .x(d => xScale(d.attempt))
                .y(d => yScale(d.correct));

            const lineIncorrect = d3.line()
                .x(d => xScale(d.attempt))
                .y(d => yScale(d.incorrect));

            // A帽adir la l铆nea de correctas
            svg.append("path")
                .data([data])
                .attr("class", "line-correct")
                .attr("d", lineCorrect);

            // A帽adir los puntos para correctas
            svg.selectAll(".dot-correct")
                .data(data)
                .enter().append("circle")
                .attr("class", "dot dot-correct")
                .attr("cx", d => xScale(d.attempt))
                .attr("cy", d => yScale(d.correct))
                .attr("r", 4) // Radio del punto
                .style("fill", "#4caf50") // Color del punto (verde)
                .style("stroke", "white"); // Borde blanco

            // A帽adir la l铆nea de incorrectas
            svg.append("path")
                .data([data])
                .attr("class", "line-incorrect")
                .attr("d", lineIncorrect);

            // A帽adir los puntos para incorrectas
            svg.selectAll(".dot-incorrect")
                .data(data)
                .enter().append("circle")
                .attr("class", "dot dot-incorrect")
                .attr("cx", d => xScale(d.attempt))
                .attr("cy", d => yScale(d.incorrect))
                .attr("r", 4) // Radio del punto
                .style("fill", "#ff9800") // Color del punto (naranja)
                .style("stroke", "white"); // Borde blanco


            // --- Eliminar funcionalidad de Tooltip ---
            // Se elimina la creaci贸n del elemento tooltip en window.onload y los event listeners mouseover/mouseout aqu铆.
            // Si se desea una alternativa, se puede descomentar el c贸digo de etiquetas est谩ticas.

            // Opcional: A帽adir etiquetas de texto est谩tico sobre los puntos
            // Esto puede saturar el gr谩fico si hay muchos intentos.
            /*
            attempts.selectAll(".text-correct")
                .data(d => [d]) // Bind data to each point group
                .enter().append("text")
                .attr("class", "bar-label") // Reutilizar clase si es necesario
                .attr("x", d => xScale(d.attempt))
                .attr("y", d => yScale(d.correct) - 8) // Posicionar encima del punto
                .attr("dy", ".35em")
                .text(d => d.correct)
                .style("fill", "#4caf50") // Color del texto (verde)
                .style("text-anchor", "middle")
                .style("font-size", "0.7em");

            attempts.selectAll(".text-incorrect")
                 .data(d => [d]) // Bind data to each point group
                .enter().append("text")
                .attr("class", "bar-label") // Reutilizar clase si es necesario
                .attr("x", d => xScale(d.attempt))
                .attr("y", d => yScale(d.incorrect) - 8) // Posicionar encima del punto
                 .attr("dy", ".35em")
                .text(d => d.incorrect)
                .style("fill", "#ff9800") // Color del texto (naranja)
                .style("text-anchor", "middle")
                .style("font-size", "0.7em");
            */


            // Ajustar el tama帽o del SVG para que sea responsivo (b谩sico)
            // No es necesario redibujar todo en redimensionamiento si se usa viewBox y preserveAspectRatio
            // d3.select(window).on('resize', () => {
            //     drawProgressChart();
            // });
        }


        // Funci贸n para cambiar de pesta帽a
        function changeTab(tabId) {
            // Ocultar todo el contenido de las pesta帽as
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Desactivar todos los botones de pesta帽a
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Mostrar el contenido de la pesta帽a seleccionada
            document.getElementById(tabId).classList.add('active');

            // Activar el bot贸n de la pesta帽a seleccionada
            document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');

            // Si la pesta帽a de progreso est谩 activa, dibujar el gr谩fico
            if (tabId === 'progress-tab') {
                drawProgressChart();
            }
        }

        // Funci贸n para iniciar un nuevo quiz con la configuraci贸n actual
        function startNewQuiz() {
            // Leer los valores de configuraci贸n
            const requestedQuestions = parseInt(numQuestionsInput.value, 10);
            const requestedTime = parseInt(quizTimeInput.value, 10);

            // Validar los valores de configuraci贸n
            if (isNaN(requestedQuestions) || requestedQuestions < 1 || requestedQuestions > originalQuizData.length) {
                alert(`Por favor, ingresa un n煤mero de preguntas v谩lido entre 1 y ${originalQuizData.length}.`);
                return;
            }
            if (isNaN(requestedTime) || requestedTime < 10 || requestedTime > 300) { // M铆nimo 10s, M谩ximo 300s (5 minutos)
                alert("Por favor, ingresa un tiempo v谩lido entre 10 y 300 segundos (5 minutos).");
                return;
            }

            // Aplicar la configuraci贸n
            numberOfQuestions = requestedQuestions;
            totalQuizTime = requestedTime;

            // Reiniciar el estado del quiz
            currentQuestionIndex = 0;
            score = 0;
            quizActive = true;

            // Mezclar las preguntas (solo el n煤mero configurado)
            shuffledQuizData = shuffleArray([...originalQuizData]).slice(0, numberOfQuestions);

            // Reiniciar la visualizaci贸n del puntaje
            scoreAttemptedButton.textContent = `Intentadas: 0`;
            scoreCorrectButton.textContent = `Correctas: 0`;
            scoreIncorrectButton.textContent = `Incorrectas: 0`;

            // Ocultar pantalla final y mostrar contenido del quiz
            endScreenElement.classList.add('hidden');
            quizContentElement.classList.remove('hidden');
            scoreContainerElement.classList.remove('hidden');
            progressChartContainer.classList.add('hidden'); // Ocultar gr谩fico

            // Iniciar temporizador y cargar primera pregunta
            startGlobalTimer();
            loadQuestion();

            // Cambiar a la pesta帽a de Entrenamiento
            changeTab('quiz-tab');

            console.log(`Quiz iniciado con ${numberOfQuestions} preguntas y ${totalQuizTime} segundos.`);
        }


        // Funci贸n para reiniciar el quiz desde la pantalla final
        function restartQuiz() {
            console.log("Reiniciando quiz desde pantalla final..."); // Log de depuraci贸n
            // Al reiniciar desde la pantalla final, usamos la configuraci贸n del 煤ltimo intento
            // o la configuraci贸n por defecto si es el primer intento.
            // No cambiamos la configuraci贸n aqu铆, solo reiniciamos el estado y cargamos.

            currentQuestionIndex = 0; // Reiniciar 铆ndice de pregunta
            score = 0; // Reiniciar puntaje
            quizActive = true; // Marcar el quiz como activo

            // Mezclar las preguntas nuevamente al reiniciar (usando el n煤mero configurado)
            shuffledQuizData = shuffleArray([...originalQuizData]).slice(0, numberOfQuestions);

            // Reiniciar la visualizaci贸n del puntaje antes de cargar la primera pregunta
            scoreAttemptedButton.textContent = `Intentadas: 0`;
            scoreCorrectButton.textContent = `Correctas: 0`;
            scoreIncorrectButton.textContent = `Incorrectas: 0`;

            // Asegurarse de que el bot贸n de responder est茅 visible y los de siguiente/reiniciar ocultos
            submitButton.classList.remove('hidden');
            nextButton.classList.add('hidden');
            restartButton.classList.add('hidden'); // Asegurarse de que el bot贸n de reiniciar est茅 oculto

            // Habilitar las opciones de respuesta antes de cargar la pregunta
            enableOptions(); // Llamar a enableOptions aqu铆 tambi茅n

            loadQuestion(); // Cargar la primera pregunta
            startGlobalTimer(); // Iniciar el temporizador global

            // Ocultar la pantalla final al iniciar un nuevo quiz
            endScreenElement.classList.add('hidden');
            // Asegurarse de que el contenido del quiz est茅 visible
            quizContentElement.classList.remove('hidden');
            // Asegurarse de que el contenedor de puntaje principal sea visible
            scoreContainerElement.classList.remove('hidden');
            progressChartContainer.classList.add('hidden'); // Ocultar el gr谩fico al reiniciar

            // Cambiar a la pesta帽a de Entrenamiento
            changeTab('quiz-tab');
            console.log("Quiz reiniciado."); // Log de depuraci贸n
        }


        // Funci贸n para alternar el modo oscuro
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            // Opcional: guardar la preferencia en localStorage para que persista
            if (document.body.classList.contains('dark-mode')) {
                localStorage.setItem('darkMode', 'enabled');
            } else {
                localStorage.setItem('darkMode', 'disabled');
            }
            // Redibujar el gr谩fico para aplicar estilos de modo oscuro si est谩 visible
            if (!progressChartContainer.classList.contains('hidden')) {
                drawProgressChart();
            }
        }


        // Este c贸digo se ejecutar谩 una vez que toda la p谩gina HTML est茅 completamente cargada
        window.onload = () => {
            // Obtener referencias a los elementos del DOM
            questionTextElement = document.getElementById('question-text');
            optionsAreaElement = document.getElementById('options-area');
            submitButton = document.getElementById('submit-answer');
            nextButton = document.getElementById('next-question');
            restartButton = document.getElementById('restart-quiz'); // Obtener referencia al bot贸n de reiniciar
            feedbackAreaElement = document.getElementById('feedback-area');
            scoreContainerElement = document.getElementById('score-area'); // Referencia al contenedor
            timerAreaElement = document.getElementById('timer-area');
            quizContentElement = document.getElementById('quiz-content');
            endScreenElement = document.getElementById('end-screen');
            darkModeToggle = document.getElementById('dark-mode-toggle'); // Referencia al bot贸n de modo oscuro
            sessionHistoryList = document.getElementById('session-history-list'); // Referencia a la lista del historial
            clearHistoryButton = document.getElementById('clear-history-button'); // Referencia al bot贸n de borrar historial
            progressChartContainer = document.querySelector('.progress-chart-container'); // Referencia al contenedor del gr谩fico
            progressChartElement = document.getElementById('progress-chart'); // Referencia al elemento donde dibujar el gr谩fico
            tabButtons = document.querySelectorAll('.tab-button'); // Referencia a los botones de pesta帽a
            tabContents = document.querySelectorAll('.tab-content'); // Referencia al contenido de las pesta帽as
            downloadCsvButton = document.getElementById('download-csv-button'); // Referencia al bot贸n de descarga CSV
            numQuestionsInput = document.getElementById('num-questions'); // Input para n煤mero de preguntas
            quizTimeInput = document.getElementById('quiz-time'); // Input para tiempo del quiz
            startQuizButton = document.getElementById('start-quiz-button'); // Bot贸n para iniciar quiz desde config


            // Establecer el valor m谩ximo para el input de n煤mero de preguntas
            numQuestionsInput.max = originalQuizData.length;


            // Crear los elementos para los botones de puntaje
            scoreAttemptedButton = document.createElement('span');
            scoreAttemptedButton.classList.add('score-button', 'attempted');
            scoreContainerElement.appendChild(scoreAttemptedButton);

            scoreCorrectButton = document.createElement('span');
            scoreCorrectButton.classList.add('score-button', 'correct');
            scoreContainerElement.appendChild(scoreCorrectButton);

            scoreIncorrectButton = document.createElement('span');
            scoreIncorrectButton.classList.add('score-button', 'incorrect');
            scoreContainerElement.appendChild(scoreIncorrectButton);

            // --- Eliminar creaci贸n de Tooltip aqu铆 ---
            // El elemento tooltip y su l贸gica de mouseover/mouseout se eliminan de drawProgressChart.


            // Event listeners para los botones de acci贸n
            submitButton.addEventListener('click', checkAnswer);
            nextButton.addEventListener('click', nextQuestion);
            restartButton.addEventListener('click', restartQuiz); // Event listener para el bot贸n de reiniciar
            darkModeToggle.addEventListener('click', toggleDarkMode); // Event listener para el bot贸n de modo oscuro
            clearHistoryButton.addEventListener('click', clearSessionHistory); // Event listener para borrar historial
            downloadCsvButton.addEventListener('click', downloadCSV); // Event listener para descargar CSV
            startQuizButton.addEventListener('click', startNewQuiz); // Event listener para iniciar nuevo quiz desde config


            // Event listeners para los botones de pesta帽a
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    changeTab(tabId);
                });
            });


            // Cargar la preferencia de modo oscuro guardada (si existe)
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
            }

            // Cargar y mostrar el historial de sesiones al cargar la p谩gina
            displaySessionHistory();

            // Inicializar la interfaz mostrando la primera pesta帽a (Configuraci贸n)
            changeTab('config-tab');

            // No iniciar el quiz autom谩ticamente, esperar al bot贸n de inicio
            // startGlobalTimer(); // Eliminado
            // loadQuestion(); // Eliminado
        };

    </script>

</body>

</html>